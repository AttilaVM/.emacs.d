#+TITLE: Emacs configuration
#+AUTHOR: Attila V. Moln√°r
#+OPTIONS: toc:4 h:4
#+STARTUP overview

* Introduction
** Rationale
I recently recreate my Linux workflow from the ground, I switched to NixOS with Xmonad, use Ansible for portable user configuration, and more importantly I am rewriting my Emacs configuration in [[https://orgmode.org/worg/org-contrib/babel/intro.html][Org Mode Babel]], using [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]]. A Org Babel is a meta programming language, no not like Lisp ;) with org mode you can meta program and glue together any kind of programming languages, in surprisingly convenient way. It is something what [[https://jupyter.org/][Jupyter Notebook]] will become in one hundred years if we are lucky
.
I have a lot of going on so I have no time to explain everything, yet... Thankfully there are brilliant examples out there, like [[http://pages.sachachua.com/.emacs.d/Sacha.html#babel-init][Sacha Chua's Emacs Configuration]], which has  nice explanations.
** Goals
*** Short term
 - Should be easy to reproduce.
 - Should be easy to reason about.
 - Ergonomic, yet mnemonic hotkeys, traditional common, Emacs and Unix hotkey bindings are mostly sacrificed.
 - Should be Fast
 - Should use Lazy module loading.
*** Long term
 - Should be cross platform
 - Should be Easily adaptable by others.
*** Very long term
 - Neural interface ;)
* Environment

You need a rather unique environment to use this configuration. First you need to change your key map. On X you need to create a =~/.Xmodmap= file:

#+begin_src

clear lock

keycode 66 = Hyper_L
remove mod4 = Hyper_L
add mod3 = Hyper_L

keycode 78 = Caps_Lock
keycode 127 = Tab
keycode 23 = Alt_L
keycode 36 = Alt_R

keycode 104 = Return

#+end_src

It maps the =hyper= ([[https://en.wikipedia.org/wiki/Space-cadet_keyboard][big thanks to the ancient Space-cadet keyboard]]) modifier key to physical =Caps Lock= , =Left Alt= to =Tab= and =Right Alt= to =Return= (Enter) and =Caps Lock= to =Insert=. Yep this will eliminate your =Tab=, =Reture= and =Insert= keys. However we can devise a way to make a modifier key act as a regular key if pressed and released without pressing another key by using [[https://github.com/alols/xcape][xcape]]. Use your package manager to install it, and run the following command after your X startup.:

#+begin_src
xcape -t 150 -e "Hyper_L=Insert;Alt_L=Tab;Alt_R=Return"
#+end_src

Solved. If you wonder why on earth we put the =Insert= key to such a convenient position, since it invokes a totally useless functionality... Well that it is the point, since nobody will miss the text overwriting mode we can bind =Insert= (physically =Caps Lock=) as an universal prefix key in our applications, which has support for concatenating hotkey strokes like *Emacs*, *Tmux*, *Xmonad* and with some python hackery *Blender*. To prove my point I will list some of my Emacs key bindings.

| virtual binding | functionality                          |
|-----------------+----------------------------------------|
| <insert> p p    | List all version controlled projects   |
| <insert> p f    | List all file in project               |
| <insert> ; h    | Select whole buffer                    |
| <insert> ; d    | Select a region between two avy jumps |

* User info

Here is where the configuration actually begins.

#+begin_src emacs-lisp :tangle yes

	(defvar user-cursor-color "#a6e22e")
	(defvar user-seek-mode-color "#E52B50")
	(defvar user-revision-mode-color "#60E896")
	(defvar user-backup-dir "~/.emacs.d/backup/")
	(defvar user-auto-save-dir "~/.emacs.d/auto-save/")
	(defvar user-big-buffer-char-limit 100000 "Some feature will be disabled for optimalization if the buffers character number is larger tha this limit")

#+end_src

#+RESULTS:
: user-big-buffer-char-limit

* pre-configuration
** Elisp
*** Require common lisp

#+begin_src emacs-lisp :tangle yes
    (require 'cl)
#+end_src

*** binding and recursion limits

Set the maximum numbers of variable bindings, recursive call limit, garbage collector threshold and set CWD to =~/.emacs.d=.

#+begin_src emacs-lisp :tangle yes
  (setq max-specpdl-size 10000)
  (setq max-lisp-eval-depth 10000)
#+end_src

*** Garbage collection byte threshold

Emacs has a blocking garbage collector, and its collection threshold is very low by default (8KB), so much of time is spent by the GC. On a modern machine this can be mitigated by increasing the GC threshold limit to 20MB, as recommended by the [[https://github.com/lewang/flx][flx package documentation]]

#+begin_src emacs-lisp :tangle yes
  (setq gc-cons-threshold 20000000)
#+end_src

*** Default directory

#+begin_src emacs-lisp :tangle yes
  (setq default-directory "~/.emacs.d")
#+end_src

** Localization

Ensure global UTF-8 usage, enable hyper and super key on windows.

#+begin_src emacs-lisp :tangle yes

	(set-language-environment "UTF-8")
	(set-default-coding-systems 'utf-8)
	(when (eq system-type "windows-nt")
		(setq w32-apps-modifier 'hyper)
		(setq w32-lwindow-modifier 'super)
		(setq w32-rwindow-modifier 'hyper))

#+end_src

#+RESULTS:

** optimizations
*** Disable bidi reordering
bidi display reordering makes Emacs significantly slower, especially when [[http://emacs.stackexchange.com/questions/598/how-do-i-prevent-extremely-long-lines-making-emacs-slow][displaying long lines]].

#+begin_src emacs-lisp :tangle yes
  (setq bidi-display-reordering nil)
#+end_src

*** Disable auto vertical scrolling
Disable auto vertical scroll adjusting for tall lines

#+begin_src emacs-lisp :tangle yes
  (setq auto-window-vscroll nil)
#+end_src

** undefine keys

#+begin_src emacs-lisp :tangle yes

	(global-unset-key (kbd "<insert>"))
	(global-unset-key (kbd "<left>"))
	(global-unset-key (kbd "<right>"))
	(global-unset-key (kbd "<up>"))
	(global-unset-key (kbd "<down>"))
	(global-unset-key (kbd "C-n"))
	(global-unset-key (kbd "C-p"))
	(global-unset-key (kbd "M-l"))
	(global-unset-key (kbd "M-j"))
	(global-unset-key (kbd "C-j"))
	(global-unset-key (kbd "C-l"))
	(global-unset-key (kbd "C-k"))
	(global-unset-key (kbd "C-i"))
	(global-unset-key (kbd "H-m"))
	(global-unset-key (kbd "M-m"))
	(global-unset-key (kbd "C-x c"))
	(global-unset-key (kbd "C-e"))
	(global-unset-key (kbd "M-e"))

	(global-set-key (kbd "<tab>") 'indent-for-tab-command)

#+end_src

#+RES

** Ingest my Babel library

#+begin_src emacs-lisp

	(org-babel-lob-ingest "~/emacs.d/babel-library.org")

#+end_src

* Configuration
:PROPERTIES:
:CUSTOM_ID: babel-init
:END:
	<<babel-init>>
** Bootstrap
*** Set repositories

#+begin_src emacs-lisp :tangle yes

	(unless (assoc-default "melpa" package-archives)
		(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t))
	;; (unless (assoc-default "org" package-archives)
	;;   (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t))
#+end_src

#+RESULTS:
: ((gnu . http://elpa.gnu.org/packages/) (melpa . http://melpa.org/packages/))

*** Bootstrap straight.el and use-package

=straight.el= git clone given packages and byte compiles them, while inter-operates with =use-package=.

 #+begin_src emacs-lisp :tangle yes
		 (let ((bootstrap-file
						(concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
					 (bootstrap-version 3))
			 (unless (file-exists-p bootstrap-file)
				 (with-current-buffer
						 (url-retrieve-synchronously
							"https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
							'silent 'inhibit-cookies)
					 (goto-char (point-max))
					 (eval-print-last-sexp)))
			 (load bootstrap-file nil 'nomessage))

	 (straight-use-package 'use-package)

	 ;; Print loading packages
	 (setq use-package-verbose t)
	 (setq use-package-always-ensure t)
 #+end_src

 #+RESULTS:
 : t

*** Prefer newly compile .elc files

If a file suffix is not exactly specified do not stop on the first hit, but search for the newest on. In practice this means that the newly compiled .elc files will be preferred.

#+begin_src emacs-lisp :tangle yes

	(setq load-prefer-newer t)

#+end_src

** libraries
*** Requires

#+begin_src emacs-lisp :tangle yes

	(require 'dired)

#+end_src

#+RESULTS:
: dired

*** Third-party libraries

loop: convenient loop library
async: modern async library
dash: modern Clojure like list library
diminish: hide or abbreviate minor modes in the mode line
deffered: provide the same functionality as JS promises.
el-mock: mocking library
m-buffer: buffer manipulation library
ov: overlay library
future: use future objects for sub-processes
request: convenient HTTP request library

#+begin_src emacs-lisp :tangle yes
	(use-package dash          :defer  :straight t)
	(use-package s             :defer  :straight t)
	(use-package f             :defer  :straight t)
	(use-package loop          :defer  :straight t)
	(use-package async         :defer  :straight t)
	(use-package deferred      :defer  :straight t)
	(use-package diminish      :demand :straight t)
	(use-package el-mock       :defer  :straight t)
	(use-package ghub          :defer  :straight t)
	(use-package ghub+         :defer  :straight t)
	(use-package m-buffer      :defer  :straight t)
	(use-package ov            :defer  :straight t)
	(use-package pfuture       :defer  :straight t)
	(use-package request       :defer  :straight t)
#+end_src

#+RESULTS:

** Helper functions
*** Elisp
**** Detect if any Emacs server running

Emacs built-in function =server-running-p= can only speak for its own Emacs instance.

#+begin_src emacs-lisp :tangle yes

	(defun attila/server-running-p ()
		"Returs true if an Emacs server is running on the system."
		(if (file-exists-p "/tmp/emacs1000/emacs-server-file")
				t
			nil))

#+end_src

#+RESULTS:
: attila/server-running-p

**** Add function to multiple hooks

 #+begin_src emacs-lisp :tangle yes

   (defun attila/add-hooks (hooks mode)
     "Add one mode to multiple hooks"
     (dolist (hook hooks)
       (add-hook hook mode)))

 #+end_src

 #+RESULTS:
 : attila/add-hooks

**** Get first value from list which evaluates true by predicate

 #+begin_src emacs-lisp :tangle yes

   (defun attila/get-first-true (list filter)
     "Get first value from list which evaluates true by predicate"
     (when list
       (if (funcall filter (car list))
           (car list)
         (attila/get-first-true (cdr list) filter))))

 #+end_src

**** association lists
***** Merge alists

Borrowed from marshal.el

#+begin_src emacs-lisp :tangle yes

	(defun attila/alist-merge (alist1 alist2 &optional append)
		(let ((res alist1))
			(if alist2
					(let* ((pair (car alist2))
								 (x (car pair))
								 (y (cdr pair)))
						(marshal--alist-merge
						 (marshal--alist-add alist1 x y append)
						 (cdr alist2)))
				alist1)))

#+end_src

#+RESULTS:
: attila/alist-merge

**** Get buffer size in line numbers

#+begin_src emacs-lisp :tangle yes

	(defun attila/buffer-size-line-in-numbers ()
		(line-number-at-pos (point-max)))

#+end_src

#+RESULTS:
: attila/buffer-size-line-in-numbers

**** Line character ratio

Emacs gets really slow when very long lines are present. We will use this value for disable some feature in favor of speed in that scenario.

#+begin_src emacs-lisp :tangle yes

	(defun attila/buffer-line-char-ratio ()
		(interactive)
		(/ (float (attila/buffer-size-line-in-numbers))
			 (float (point-max))))

#+end_src

#+RESULTS:
: attila/buffer-line-char-ratio

**** Big buffer predicate

#+begin_src emacs-lisp :tangle yes

	(defun attila/big-buffer-p ()
		(if (and (> (attila/buffer-line-char-ratio) 0.1)
						 (> (point-max) user-big-buffer-char-limit))
				t
			nil))

#+end_src

#+RESULTS:
: attila/big-buffer-p

**** Easy converters

#+begin_src emacs-lisp :tangle yes

	(defun attila/to-string (val)
			(cond ((number-or-marker-p val)
						 (number-to-string val))
						((string-or-null-p val)
						 val)))

#+end_src

#+RESULTS:
: attila/to-string

**** Up Case or Down case

#+begin_src emacs-lisp :tangle yes
(defun attila/up-case-p (char)
	(> ?a char))
#+end_src

#+RESULTS:
: attila/up-case-p

*** UX
**** Smart line beginning
#+begin_src emacs-lisp :tangle yes
  (defun attila-smart-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+end_src

**** small step scrolls

#+begin_src emacs-lisp :tangle yes

	(defun attila/scroll-down-1-line ()
		(interactive)
		(scroll-down 1))

	(defun attila/scroll-up-1-line ()
		(interactive)
		(scroll-up 1))

#+end_src

#+RESULTS:
: attila/scroll-up-1-line

**** Smart rename

Rename buffer or file and buffer if it is already saved.

#+begin_src emacs-lisp :tangle yes

	(defun attila/smart-rename-buffer-file (new-name)
		"Renames both current buffer and file (if saved) it's visiting to NEW-NAME."
		(interactive (list (read-string "New Name: " (buffer-name))))
		(let ((name (buffer-name))
					(filename (buffer-file-name)))
			(if (get-buffer new-name)
					(message "A buffer named '%s' already exists!" new-name)
				(progn
					(when (file-exists-p filename)
						(rename-file filename new-name 1))
					(rename-buffer new-name)
					(set-visited-file-name new-name)
					(set-buffer-modified-p nil)))))

#+end_src

#+RESULTS:
: attila/smart-rename-buffer-file

**** Cut lines

#+begin_src emacs-lisp :tangle yes

	(defun attila/line-cut (prefix-arg)
		"Cut active line"
		(interactive (list current-prefix-arg))
		(let ((line-num (if prefix-arg prefix-arg 1))
					(counter 0))
			(while (< counter line-num)
				(setq counter (+ 1 counter))
				(kill-region (line-beginning-position) (line-end-position))
				(delete-forward-char 1 nil))))


	(global-set-key (kbd "<insert> l d") 'attila/line-cut)


	(defun my/test (prefix-arg)
		(interactive (list current-prefix-arg))
		(message prefix-arg))


	;;;
	;;;
	;;
	;;

#+end_src
**** Multiply line above/below

#+begin_src emacs-lisp :tangle yes

		(defun attila/line-duplicate-below ()
			"Duplicate active line"
			(interactive)
			;; insertion = newline + active line
			(let ((insertion (concat "\n" (buffer-substring (line-beginning-position) (line-end-position)))))
				(end-of-line)
				(insert insertion)
				;; Indent (tab) command in certain modes with automatic indention will lead to right identation
				;; Doing it at the end of the line will not cause any harm in others modes, expect in the ones
				;; where multiple identation levels carry differen meanings (python, yaml etc...)
				;; which is still a TODO task;
				(end-of-line)
				(indent-for-tab-command)))

		(defun attila/line-duplicate-above ()
			"Duplicate active line above"
			(interactive)
			;; insertion = newline + active line
			(let ((insertion (concat (buffer-substring (line-beginning-position) (line-end-position)))))
				(beginning-of-line)
				(insert "\n")
				(forward-line -1)
				(insert insertion)
				;; Indent (tab) command in certain modes with automatic indention will lead to right identation
				;; Doing it at the end of the line will not cause any harm in others modes, expect in the ones
				;; where multiple identation levels carry differen meanings (python, yaml etc...)
				;; which is still a TODO task;
				(end-of-line)
				(indent-for-tab-command)))

#+end_src
**** Up/Down case

#+begin_src emacs-lisp :tangle yes

(defun attila/up-down-case-toggle ()
	(interactive)
	(save-excursion
		(let ((beg (point))
					(is-upcase (attila/up-case-p
											(get-byte (- (point) 1)))))
			(if is-upcase
					(downcase-region beg (search-backward-regexp "[ \t\n'\"]"))
				(upcase-region beg (search-backward-regexp "[ \t\n'\"]"))))))

#+end_src

#+RESULTS:
: attila/up-down-case-toggle

** Appearance
*** Layout

#+begin_src emacs-lisp :tangle yes
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Theme and font
#+begin_src emacs-lisp :tangle yes

	(add-hook 'after-init-hook
						(lambda ()
							(set-cursor-color user-cursor-color)))

		(use-package monokai-theme
			:demand t
			:straight t)

	(when (window-system)
			(set-default-font "Fira Code"))

	;; (use-package unicode-fonts
	;; 	:straight t
	;; 	:demand t
	;; 	:config
	;; 	(unicode-fonts-setup))

#+end_src

#+RESULTS:

*** Relevant syntax highlight

#+begin_src emacs-lisp :tangle yes

	(use-package color-identifiers-mode
		:straight t)


#+end_src

#+RESULTS:

*** ANSI colorize region or buffer

#+begin_src emacs-lisp :tangle yes

	(defun attila/ansi-colorize ()
		(interactive)
		(if (use-region-p)
				(ansi-color-apply-on-region
				 (region-beginning)
				 (region-end))
			(ansi-color-apply-on-region
			 (point-min)
			 (point-max))))

#+end_src

#+RESULTS:
: attila/ansi-colorize

*** Use visual bell instead audio

#+begin_src emacs-lisp :tangle yes

  (setq ring-bell-function 'ignore)
	(setq visible-bell nil)

#+end_src

*** Parenthesis

Highlight parentheses at point and its pair. Use rainbow colors for the different nesting levels of parenthesis.

#+begin_src emacs-lisp :tangle yes
(show-paren-mode 1)

(use-package rainbow-delimiters
  :straight t
	:config
	;; Enable it in all programing modes
	(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
	;; Set colors to travel through the VIS spectrum from red to blue
	'(rainbow-delimiters-depth-1-face ((t (:foreground "light slate blue"))))
	'(rainbow-delimiters-depth-2-face ((t (:foreground "cyan"))))
	'(rainbow-delimiters-depth-3-face ((t (:foreground "lime green"))))
	'(rainbow-delimiters-depth-4-face ((t (:foreground "yellow green"))))
	'(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
	'(rainbow-delimiters-depth-6-face ((t (:foreground "goldenrod"))))
	'(rainbow-delimiters-depth-7-face ((t (:foreground "dark orange"))))
	'(rainbow-delimiters-depth-8-face ((t (:foreground "orange red"))))
	'(rainbow-delimiters-depth-9-face ((t (:foreground "red2")))))
#+end_src

*** Colorize strings, which represent colors

#+begin_src emacs-lisp :tangle yes

	(use-package rainbow-mode
		:straight t
		:diminish rainbow-mode "üåà"
		:init
		(attila/add-hooks
		 '(stylus-mode-hook
			 less-css-mode-hook
			 web-mode-hook
			 css-mode-hook)
		 (lambda () (rainbow-mode))))

#+end_src

#+RESULTS:
: t

*** Colorize compilation buffer

#+begin_src emacs-lisp :tangle yes
(require 'ansi-color)

(defun colorize-compilation-buffer ()
	(toggle-read-only)
	(ansi-color-apply-on-region compilation-filter-start (point))
	(toggle-read-only))

(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src

*** Highlight point on window scroll

#+begin_src emacs-lisp :tangle yes

	(use-package beacon
		:straight t
		:demand t
		:diminish beacon-mode
		:config
		(beacon-mode 1)
		(setq beacon-blink-duration 0.05)
		(setq beacon-color "#a6e22e")
		(setq beacon-blink-when-window-scrolls nil))

#+end_src

#+RESULTS:
: t

*** Highlight  page intersection on scrolling

#+begin_src emacs-lisp :tangle yes

  (use-package highlight-context-line
    :straight t
    :config
    (highlight-context-line-mode))

#+end_src

*** Smooth scrolling

#+begin_src emacs-lisp :tangle yes

	(use-package sublimity
		:straight t
		:config
		(require 'sublimity-scroll)
		(sublimity-mode 1))

#+end_src
*** Visual line wrapping

#+begin_src emacs-lisp :tangle yes

		(attila/add-hooks
		 '(Man-mode-hook
			 org-mode-hook
			 markdown-mode-hook)
		 (lambda ()
			 (visual-line-mode)))

	(diminish 'visual-line-mode "ùåì")
#+end_src

#+RESULTS:

*** Indentation adaptive visual line wrapping

#+begin_src emacs-lisp :tangle yes

	(use-package adaptive-wrap
		:straight t
		:diminish adaptive-wrap-prefix-mode
		:defer t
		:init
		(attila/add-hooks
		 '(prog-mode-hook
			 text-mode-hook)
		 'my-adaptive-wrap-autoload)
		:commands
		my-adaptive-wrap-autoload
		:config
		(defun my-adaptive-wrap-autoload ()
			(adaptive-wrap-prefix-mode t)))

#+end_src

#+RESULTS:
: t

** Behavior
*** Store customization in a separate file

Much better than tainting the =init.el= file.

#+begin_src emacs-lisp :tangle yes

	(setq custom-file "~/.emacs.d/custom-options.el")

#+end_src

#+RESULTS:
: ~/.emacs.d/custom-options.el

*** Universal argument

#+begin_src emacs-lisp :tangle yes

	(define-key global-map (kbd "<insert> n") 'universal-argument)
	(define-key universal-argument-map (kbd "C-u") nil)
	(define-key universal-argument-map (kbd "H-n") 'universal-argument-more)
	(define-key global-map (kbd "C-u") 'kill-whole-line)
	(eval-after-load 'evil-maps
		'(progn
			 (define-key evil-motion-state-map (kbd "H-n") nil)
			 (define-key evil-motion-state-map (kbd "C-u") 'evil-scroll-up)))

#+end_src
*** Window management
**** Force horizontal spliting

#+begin_src emacs-lisp :tangle yes

	(setq split-width-threshold 9999)

	(defun attila/window-force-horizontal-split ()
		"If there's only one window (excluding any possibly active minibuffer), then
			 split the current window horizontally."
		(interactive)
		(if (= (length (window-list nil 'dont-include-minibuffer-even-if-active)) 1)
				(split-window-horizontally)))

	(add-hook 'temp-buffer-setup-hook 'attila/window-force-horizontal-split)

#+end_src
**** Basic window-manager commands

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> 3 v") 'split-window-below)
	(global-set-key (kbd "<insert> 3 h") 'split-window-horizontally)
	;; expand active window
	(global-set-key (kbd "<insert> 3 e") 'delete-other-windows)
	(global-set-key (kbd "<insert> 3 k") 'delete-window)
	(global-set-key (kbd "<insert> 3 t") 'toggle-truncate-lines)
	(global-set-key (kbd "<insert> 3 t") 'toggle-truncate-lines)
	(global-set-key (kbd "<insert> 3 3") 'toggle-truncate-lines)

#+end_src

#+RESULTS:
: toggle-truncate-lines

*** Helm
**** Helm core
#+begin_src emacs-lisp :tangle yes

	(use-package helm
		:straight t
		:diminish helm-mode
		:config
		(require 'helm-config)
		(require 'helm-sys)
		(setq enable-recursive-minibuffers t)
		;; make helm adapt to my choices
		(helm-adaptive-mode)
		;; Make helm use the active window for interaction
		(setq
		 ;; Open helm buffer in current winsow
		 helm-split-window-in-side-p           t
		 ;; cylcle throught helm results
		 helm-move-to-line-cycle-in-source     t
		 ;; search for library in `require' and `declare-function' sexp.
		 helm-ff-search-library-in-sexp        t
																					; scroll 8 lines other window using M-<next>/M-<prior>
		 helm-scroll-amount                    8
		 ;; simultanusly displayed candiate limit
		 helm-candidate-number-limit 100
		 ;; delay to update candidate list
		 helm-input-idle-delay 0.1
		 ;; Use the recent file, when finding files
		 helm-ff-file-name-history-use-recentf t)
		(helm-mode 1)

		;; Use helm for file finding
		(global-unset-key (kbd "C-x C-f"))
		;; make sure C-h is no longer a prefix key inside a helm buffer
		(define-key helm-map (kbd "C-h") nil)
		:bind
		(
		 ("<insert> x f" . helm-find-files)
		 ("<insert> x r" . helm-recentf)
		 ("<insert> x d" . dired)
		 ("<insert> b b" . switch-to-buffer)
		 ;; Use helm for command prompt
		 ("M-x" . helm-M-x)
		 ("<insert> <insert>" . helm-M-x)
		 ;; Use helm-buffers-list instead of default helm buffer lister
		 ("s-x b" . helm-buffers-list)
		 ;; get the list of the bookmarks (C-x r m for saving bookmarks)
		 ("C-c p j" . helm-bookmarks)
		 ;; More easier way to acces Emacs's internal "clipboard"
		 ("<insert> i h" . helm-show-kill-ring) ;; as clipboard history
		 ;; Use helm with isearch
		 ("<insert> s s" . helm-occur)
		 ;; resume to previous search
		 ("<insert> s r" . helm-resume)
		 ;; Show kill-ring
		 ("<insert> i h" . helm-show-kill-ring)
		 ;; helm-ls-git
		 ("C-<f6>" . helm-browse-project)
		 ;; helm imenu
		 ("<insert> s i" . helm-imenu)
		 ;; helm-c-source-yasnippet
		 ("<insert> e e" . helm-yas-complete)
		 ("<insert> e f" . helm-yas-visit-snippet-file)
		 ("<insert> e r" . helm-yas-create-snippet-on-region)
		 ;; helm top
		 ("<insert> 2 s o" . helm-top)
		 ("<insert> x t" . helm-tramp )
		 ;; helm locate
		 ("<insert> s l" . helm-locate)
		 ;; show killring
		 ("<insert> q" . helm-show-kill-ring)
		 ;; helm help
		 ("<insert> h w" . helm-man-woman)
		 ("<insert> h i e" . helm-info-elisp)
		 ("<insert> h i m" . helm-info-magit)
		 ("<insert> h i z" . helm-info-zsh)
		 ("<insert> h e a" . helm-apropos)
		 ("<insert> h e f" . describe-function)
		 ("<insert> h e k" . describe-key-briefly)
		 ("<insert> h e m" . describe-mode)
		 ;; ???
		 ("<C-kp-4>" . sm/toggle-showcss)
		 ("<insert> i c" . helm-colors))
		:bind
		(:map helm-map
					("<insert> j j" . helm-select-action)
					("<insert> r" . helm-ff-run-find-file-as-root)
					("<insert> d d" . dired-find-file)
					("<insert> d o" . dired-find-file)
					("C-k" . helm-next-line)
					("C-i" . helm-previous-line)
					("C-j" . helm-execute-persistent-action)
					)
		(:map helm-find-files-map
					("C-j" . helm-find-files-up-one-level)
					("C-l" . helm-execute-persistent-action))
		(:map helm-read-file-map
					("C-j" . helm-find-files-up-one-level)
					("C-l" . helm-execute-persistent-action))
		(:map helm-top-map
					("<insert> j c" . helm-top-run-sort-by-cpu)
					("<insert> j m" . helm-top-run-sort-by-mem)
					("<insert> j k" . 'helm-top-run-sort-by-com)
					("<insert> j u" . 'helm-top-run-sort-by-user)
					))

#+end_src

#+RESULTS:
: t

**** Helm projectile

#+begin_src emacs-lisp :tangle yes

	(use-package projectile
		:straight t
		:diminish projectile-mode
		:config
		(use-package helm-projectile
			:straight t
			:config
			(helm-projectile-on))
		(projectile-global-mode)
		(setq projectile-globally-ignored-directories
					(append '(
										"out"
										"target"
										"venv"
										"node_modules"
										) ))
		(setq projectile-known-projects-file "~/.emacs.d/projectile-bookmarks.eld")
		(setq projectile-enable-caching t)
		(use-package helm-ag :straight t)
		:bind
		("<insert> s a" . helm-do-ag)
		("<insert> p p" . helm-projectile-switch-project)
		("<insert> p +" . projectile-add-known-project)
		("<insert> p -" . projectile-remove-known-project)
		("<insert> p f" . helm-projectile-find-file)
		("<insert> p b" . helm-projectile-switch-to-buffer)
		("<insert> p i" . projectile-invalidate-cache)
		;; Extreamly fast mehotd search in all recent project files.
		("<insert> p a" . helm-projectile-ag)
		("<insert> s p" . helm-projectile-ag)
		("<insert> x p" . projectile-save-project-buffers)
		;; Very slow, when many project is present.
		("<insert> p g" . helm-projectile-find-file-in-known-projects)
		;; Project level replace, what can go wrong?
		("<insert> p r t" . projectile-replace)
		("<insert> p r r" . projectile-replace-regexp))

#+end_src

#+RESULTS:
: projectile-replace-regexp

**** helm swoop

#+begin_src emacs-lisp :tangle yes

	(use-package helm-swoop
		:commands helm-swoop
		:straight t
		:bind
		(("<insert> s w w" . helm-swoop)
		 ("<insert> s w p" . helm-multi-swoop-projectile)
		 ("<insert> s w o" . helm-multi-swoop-org))
		(:map helm-swoop-map
					("<insert> j s" . helm-swoop-edit)
					)
		(:map helm-swoop-edit-map
					("<insert> C-c C-c" . helm-swoop--edit-complete)
					("<insert> C-c C-k" . helm-swoop--edit-cancel)))

#+end_src

#+RESULTS:
: helm-swoop--edit-cancel

*** GUI interaction
**** Basic control

#+begin_src emacs-lisp :tangle yes

  (global-set-key (kbd "<insert> <escape>") 'save-buffers-kill-terminal)
  (global-set-key (kbd "<insert> x x") 'save-buffer)

#+end_src
**** Prevent backgrounding

#+begin_src emacs-lisp :tangle yes

  (when (display-graphic-p)
    (progn
      (global-unset-key (kbd "C-z"))
      (global-unset-key (kbd "C-x C-z"))))

#+end_src

**** buffer operations

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> b K") 'kill-matching-buffers)
	(global-set-key (kbd "<insert> b r") 'attila/smart-rename-buffer-file)
	(global-set-key (kbd "<insert> r t") 'query-replace)
	(global-set-key (kbd "<insert> b k") 'kill-buffer)
	(global-set-key (kbd "<insert> x a") 'save-some-buffers)
	(global-set-key (kbd "<insert> x o") 'find-file-read-only)
	(global-set-key (kbd "<insert> <escape>") 'save-buffers-kill-terminal)
	(global-set-key (kbd "<insert> x x") 'save-buffer)
	(global-set-key (kbd "<insert> SPC SPC") 'set-mark-command)

#+end_src

#+RESULTS:
: set-mark-command

*** Navigation
**** Switch&rotate windows, switch frames
#+begin_src emacs-lisp :tangle yes

  (defun rotate-windows (arg)
    "Rotate your windows; use the prefix argument to rotate the other direction"
    (interactive "P")
    (if (not (> (count-windows) 1))
        (message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
             (direction (if (or (< rotate-times 0) (equal arg '(4)))
                            'reverse 'identity)))
        (dotimes (_ (abs rotate-times))
          (dotimes (i (- (count-windows) 1))
            (let* ((w1 (elt (funcall direction (window-list)) i))
                   (w2 (elt (funcall direction (window-list)) (+ i 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2))
                   (p1 (window-point w1))
                   (p2 (window-point w2)))
              (set-window-buffer-start-and-point w1 b2 s2 p2)
              (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (global-set-key (kbd "M-o") 'rotate-windows)
  (global-set-key (kbd "H-o") 'other-window)
  (global-set-key (kbd "C-o") 'other-frame)

#+end_src

**** Move chars and lines

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "H-j") 'backward-char)
  (global-set-key (kbd "H-l") 'forward-char)
  (global-set-key (kbd "H-k") 'next-line)
  (global-set-key (kbd "H-i") 'previous-line)
#+end_src

**** Scroll up/down move sub-words

#+begin_src emacs-lisp :tangle  yes

  (global-set-key (kbd "M-i") 'scroll-down-command)
  (global-set-key (kbd "M-k") 'scroll-up-command)
  (global-set-key (kbd "M-l") 'forward-word)
  (global-set-key (kbd "M-j") 'backward-word)

#+end_src

**** sub-word jumps

#+begin_src emacs-lisp :tangle yes
	(attila/add-hooks
	 '(js-mode-hook
		 org-mode-hook
		 clojure-mode-hook
		 python-mode-hook
		 java-mode-hook
		 c-mode-hook
		 haskell-mode-hook
		 jade-mode-hook
		 elm-mode-hook
		 julia-mode-hook
		 stylus-mode-hook)
	 'subword-mode)
#+end_src

#+RESULTS:

**** Beginning of line and buffer

#+begin_src emacs-lisp :tangle yes
	(global-set-key (kbd "H-M-j") 'attila-smart-move-beginning-of-line)
	(global-set-key (kbd "H-M-l") 'move-end-of-line)
	(global-set-key (kbd "C-i") 'beginning-of-buffer)
	(global-set-key (kbd "C-k") 'end-of-buffer)
#+end_src

#+RESULTS:
: end-of-buffer

**** Jump to char char-pair or line

I use key-chords to invoke avy functions

#+begin_src emacs-lisp :tangle yes

	(use-package avy
		:straight t
		:config
		(avy-setup-default)

		(defun attila/avy-select-char ()
			(interactive)
			(call-interactively 'avy-goto-char)
			(call-interactively 'set-mark-command)
			(call-interactively 'avy-goto-char))

		(defun attila/avy-select-char-2 ()
			(interactive)
			(call-interactively 'avy-goto-char-2)
			(call-interactively 'set-mark-command)
			(call-interactively 'avy-goto-char-2))
		:bind
		("<insert> ; d" . attila/avy-select-char-2)
		("<insert> ; f" . attila/avy-select-char))


#+end_src

#+RESULTS:
: attila/avy-select-char

**** Go back and forth changed regions

#+begin_src emacs-lisp :tangle yes

  (use-package goto-chg
    :straight t
    :bind
    (("C-u" . goto-last-change)
     ("C-S-u" . goto-last-change-reverse)))

#+end_src

**** Sentences postfixed with one space by modern people

#+begin_src emacs-lisp :tangle yes

	(setq sentence-end-double-space nil)

#+end_src

#+RESULTS:

**** Forward/backward sexp and sentences

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "H-'") 'forward-sexp)
	(global-set-key (kbd "H-;") 'backward-sexp)
	(global-set-key (kbd "M-'") 'forward-sentence)
	(global-set-key (kbd "M-;") 'backward-sentence)

#+end_src

#+RESULTS:
: backward-sentence

**** Forward/backward sentence

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "H-M-;") 'backward-sentence)
  (global-set-key (kbd "H-M-'") 'forward-sentence)

#+end_src

#+RESULTS:
: forward-sentence

*** key chords

#+begin_src emacs-lisp :tangle yes

	(use-package key-chord
		:straight t
		:init
		(add-hook 'after-init-hook
							(lambda () (key-chord-mode t)))
		:config
		(require 'key-chord)
		(setq key-chord-two-keys-delay 0.08)
		(setq key-chord-one-key-delay 0.08)
		(key-chord-define-global "jf" 'avy-goto-char)
		(key-chord-define-global "jd" 'avy-goto-char-2)
		(key-chord-define-global "jg" 'avy-goto-line)
		(key-chord-define-global "kd" 'kill-word)
		(key-chord-define-global "kf" 'backward-kill-word))

#+end_src

#+RESULTS:
: t

*** Selection
**** Select whole buffer

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> ; h") 'mark-whole-buffer)

#+end_src

#+RESULTS:
: mark-whole-buffer

**** Expand region
Bindings defined with hydra

#+begin_src emacs-lisp :tangle yes

	(use-package expand-region
		:straight t
		:commands
		er/expand-region
		er/contract-region)

#+end_src

*** Show function synopsis with eldoc

Allow eldoc to show function synopsis in the echo area in multiple line if needed.

#+begin_src emacs-lisp :tangle yes

  (use-package eldoc
    :straight t
    :defer t
    :diminish eldoc-mode
    :init
    (attila/add-hooks
     '(emacs-lisp-mode-hook)
     'turn-on-eldoc-mode)
    :config
    (setq eldoc-echo-area-use-multiline-p t))


#+end_src

#+RESULTS:
: t

*** Editor server

Run Emacs as a server and connect to it with =emacsclient= from the CLI. This function however can detect other Emacs server instances.

#+begin_src emacs-lisp :tangle yes

	(require 'server)
	(unless (attila/server-running-p)
		(cond
		 ((eq system-type 'windows-nt)
			(setq server-auth-dir "~\\.emacs.d\\server\\"))
		 ((eq system-type 'gnu/linux)
			(setq server-auth-dir "~/.emacs.d/server/")))
		(setq server-name "emacs-server-file")
		(server-start))

#+end_src

*** Recently edited files

#+begin_src emacs-lisp :tangle yes

	(require 'recentf)
	(setq recentf-max-saved-items 300)
	(setq recentf-max-menu-items 20)

#+end_src

#+RESULTS:
: 20


*** History navigation hotkeys

#+begin_src emacs-lisp :tangle yes
(define-key comint-mode-map (kbd "M-i") 'previous-history)
(define-key comint-mode-map (kbd "M-i") 'next-history-element)
#+end_src

#+RESULTS:
: next-history-element

*** Centralized backup and auto-clean backup dir

Make Emacs to write backup and auto-save files in a [[https://www.emacswiki.org/emacs/BackupDirectory][specific directory]] instead of messing up the project file trees.

#+begin_src emacs-lisp :tangle yes
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files nil)

(unless (file-directory-p user-backup-dir)
	(make-directory user-backup-dir))

(unless (file-directory-p user-auto-save-dir)
	(make-directory user-auto-save-dir))

(setq backup-directory-alist
			`((".*" . ,user-backup-dir)))
(setq auto-save-file-name-transforms
			`((".*" ,user-auto-save-dir t)))

#+end_src

#+RESULTS:
| .* | /tmp/ | t |

Delete backup files older then a week

#+begin_src emacs-lisp :tangle yes

  (let ((week (* 60 60 24 7))
        (current (float-time (current-time))))
    (dolist (file (directory-files user-backup-dir t))
      (when (and (backup-file-name-p file)
                 (> (- current (float-time (fifth (file-attributes file))))
                    week))
        (message "%s" file)
        (delete-file file))))

#+end_src

#+RESULTS:

*** Make scripts executable after save

#+begin_src emacs-lisp :tangle yes

  (add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)


#+end_src

*** Respect  .editorconfig file

#+begin_src emacs-lisp :tangle yes
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

*** Open files with external app

Borrowed from Sacha's config, original source: http://emacsredux.com/blog/2013/03/27/open-file-in-external-program/

modified it to use async shell command.

#+begin_src emacs-lisp :tangle yes

	(defun attila/prelude-open-with (arg)
		"Open visited file in default external program.

	With a prefix ARG always prompt for command to use."
		(interactive "P")
		(when buffer-file-name
			(async-shell-command (concat
														(cond
														 ((and (not arg) (eq system-type 'darwin)) "open")
														 ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
														 (t (read-shell-command "Open current file with: ")))
														" "
														(shell-quote-argument buffer-file-name)))))

	(global-set-key (kbd "<insert> x e") 'attila/prelude-open-with)

#+end_src

#+RESULTS:
: attila/prelude-open-with

*** Whitespace cleaning

Trimming whitespaces from line endings is important, except when a project is already reaaly messed up, so this will be a switchable feature.

#+begin_src emacs-lisp :tangle yes

(defvar attila/whitespace-clean-p t "If t whitespace triming will be executed on every save.")

(defun attila/whitespace-clean-toggle ()
	(interactive)
	(setq attila/whitespace-clean-p (not attila/whitespace-clean-p))
	(if attila/whitespace-clean-p
			(message "Whitespace cleaning is ON")
		(message "Whitespace cleaning is OFF")))

(add-hook 'before-save-hook (lambda ()
															(when attila/whitespace-clean-p
																(delete-trailing-whitespace))))

(global-set-key (kbd "<insert> o w t") 'attila/whitespace-clean-toggle)
(global-set-key (kbd "<insert> o w s") 'whitespace-mode)

#+end_src

#+RESULTS:
: whitespace-mode

** Editing
*** Hydra

#+begin_src emacs-lisp :tangle yes

	(use-package hydra
		:straight t
		:config
		;; hint int the echo area
		(setq hydra-is-helpful t)
		;; Use dedicated hinting window
		(setq hydra-lv nil)
		;; Separate hinter and echo area
		(setq lv-use-separator nil)

		(defun hydra-revision/pre ()
			(set-cursor-color user-revision-mode-color)
			(setq beacon-color user-revision-mode-color)
			(attila/flyspell-mode))

		(defun hydra-revision/post ()
			(set-cursor-color user-cursor-color)
			(setq beacon-color user-cursor-color)
			(git-gutter-mode -1)
			(flyspell-mode -1))

		(defhydra hydra-sepll-check
			(global-map "<f2>"
									:color pink
									:pre hydra-revision/pre
									:post hydra-revision/post
									)
			"hydra-revision"
			("f" attila/flyspell-check-next-highlighted-word "check next")
			("x" flyspell-buffer "check buffer")
			("v" git-gutter-mode)
			("h" git-gutter:popup-hunk)
			("r" git-gutter:revert-hunk)
			;; navigation
			("i" scroll-down-command)
			("k" scroll-up-command)
			("j" attila/scroll-down-1-line)
			("l" attila/scroll-up-1-line)
			(";" git-gutter:previous-hunk)
			("'" git-gutter:next-hunk)
			("q" nil)
			;; annotation
			("a a" org-annotate-file)
			("a f a" org-annotate-file-find-storage-file)
			("a f c" org-capture-file-find-storage-file)
			("a c" org-capture)
			)

		(defun hydra-seek/pre ()
			(set-cursor-color user-seek-mode-color)
			(setq beacon-color user-seek-mode-color))

		(defun hydra-seek/post ()
			(set-cursor-color user-cursor-color)
			(setq beacon-color user-cursor-color))

		(defhydra hydra-seek
			(global-map "<insert> SPC"
									:color pink
									:pre hydra-seek/pre
									:post hydra-seek/post)
			"hydra-seek"
			("w" kill-ring-save "copy")
			("y" yank "yank")
			("SPC" set-mark-command "mark")
			("s s" helm-occur "search")
			("s w w" helm-swoop "h-swoop")
			("s w p" helm-multi-swoop-projectile "h-swoop")
			("s w o" helm-multi-swoop-org "h-swoop")
			("s w a" helm-multi-swoop-all "h-swoop")
			("s m m" helm-rifle-current-buffer)
			("s p" helm-projectile-ag "p-search")
			("s l" helm-locate "l-search")
			("s r" helm-resume "ffind")
			("x f" helm-find-files "ffind")
			("f" avy-goto-char "j1")
			("d" avy-goto-char-2 "j2")
			("g" avy-goto-line)
			("p p" helm-projectile-switch-project)
			("p f" helm-projectile-find-file)
			("b b" switch-to-buffer)
			;; Select
			("; f" attila/avy-select-char)
			("; d" attila/avy-select-char-2)
			("; h" mark-whole-buffer)
			;; Select
			("]" er/expand-region)
			("[" er/contract-region)
			("q" nil)
			;; Editing
			("l d" attila/line-cut)
			;; git
			("v v" magit-status))

		(defun hydra-dired-peep/pre ()
			(set-cursor-color user-seek-mode-color)
			(setq beacon-color user-seek-mode-color)
			(peep-dired t))

		(defun hydra-dired-peep/post ()
			(set-cursor-color user-cursor-color)
			(setq beacon-color user-cursor-color)
			(peep-dired -1))

		(defhydra hydra-dired-peep
			(:color pink
							:pre hydra-dired-peep/pre
							:post hydra-dired-peep/post)
			"hydra-seek"
			("i" peep-dired-prev-file "up")
			("k" peep-dired-next-file "down")
			("l" peep-dired-scroll-page-down "scroll-down")
			("j" peep-dired-scroll-page-up "scroll-up")
			("q" nil)
			)
		(define-key dired-mode-map "p" 'hydra-dired-peep/body)

		(defun hydra-table/pre ()
			(set-cursor-color user-seek-mode-color)
			(setq beacon-color user-seek-mode-color))

		(defun hydra-table/post ()
			(set-cursor-color user-cursor-color)
			(setq beacon-color user-cursor-color))

		(defhydra hidra-table
			(global-map "<insert> 4 t"
									:color pink
									:pre hydra-table/pre
									:post hydra-table/post)
			"hydra-table"
			("j" org-table-previous-field "left")
			("l" org-table-next-field "right")
			("f" org-table-edit-field "edit" :color blue)
			("d f" org-table-blank-field "blank field")
			("a" org-table-align)
			("C-j" org-table-move-column-left "col left")
			("C-l" org-table-move-column-right " right")
			("C-i" org-table-move-row-up "row up")
			("C-k" org-table-move-row-down "row down")
			("d r" org-table-kill-row "kill row")
			("c r" org-table-insert-row "insert row")
			("c c" org-table-insert-column "insert column")
			("c l" org-table-insert-hline "insert h-line")
			("s" org-table-sort-lines "sort")
			("M-w" org-table-copy-region "copy region")
			("C-W" org-table-cut-region "cut region")
			("C-y" org-table-paste-rectangle "paste")
			("+" org-table-sum "sum")
			("b" org-table-import "import")
			("e" org-table-export "export")
			("q" nil))

		(defhydra hydra-annotate
			(global-map "<insert> TAB a"
									:color pink)
			"Annotation hydra"
			("j" bm-previous)
			("l" bm-next)
			("e" bm-show-annotations)
			("a" bm-bookmark-annotate "annotate")
			("t" bm-toggle)
			("s" bm-show-all)
			("q" nil))
		)
#+end_src

#+RESULTS:
: t

*** Kill ring

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> y") 'helm-show-kill-ring)

#+end_src

#+RESULTS:
: helm-show-kill-ring

*** Commenting in/out

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "H-\\") 'comment-dwim)

#+end_src
*** Use spaces instead of tabs

Eloy's prefers spaces over tabs so do I. =tab-stop-list= is a fallback when =indent relative= does not find the next tab stop

#+begin_src emacs-lisp :tangle yes

  (setq-default indent-tabs-mode-mode nil)
  (setq-default tab-width 2)
  (setq tab-stop-list (number-sequence tab-width 120 tab-width))
  (defvaralias 'c-basic-offset 'tab-width)
  (defvaralias 'cperl-indent-level 'tab-width)

#+end_src

#+RESULTS:
: tab-width

*** Perl style regex for replace

#+begin_src emacs-lisp :tangle yes

	(use-package visual-regexp-steroids
		:straight t
		:commands
		vr/replace
		vr/mc-mark
		:bind
		("<insert> r r" . vr/query-replace)
		("<insert> r m" . vr/mc-mark)
		:config
		;; switch re builder syntax `string` instead of `read`, since it is more convinient
		;; source: https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder
		(setq reb-re-syntax 'string))


#+end_src

#+RESULTS:
: vr/mc-mark

*** Undo tree

#+begin_src emacs-lisp :tangle yes

	(use-package undo-tree
		:straight t
		:diminish undo-tree-mode
		:config
		(global-undo-tree-mode)
		(setq undo-tree-visualizer-timestamps t)
		(setq undo-tree-visualizer-diff t)
		:bind
		(("H-u" . undo-tree-undo)
		 ("M-u" . undo-tree-redo)
		 ("<insert> u" . undo-tree-visualize)))

#+end_src

#+RESULTS:
: undo-tree-visualize

*** Multiple cursors

#+begin_src emacs-lisp :tangle yes
	(use-package multiple-cursors
		:straight t
		:bind
		(( "H-m" . mc/mark-next-like-this)
		 ( "M-m" . mc/mark-previous-like-this)
		 ( "C-M-m" . mc/mark-all-like-this)))
#+end_src

*** Preserve point position relative to the window.

#+begin_src emacs-lisp :tangle yes
(setq scroll-preserve-screen-position t)
#+end_src

*** Ask for "y" or "n" for saving

#+begin_src emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Parentheses
**** Kill sexp when point is at ( or )

#+begin_src emacs-lisp :tangle yes

	(use-package smartparens
		:straight t
		:defer 2
		:diminish smartparens-mode "‚öñ"
		:init
		(defun attila-sp-kill-sexp ()
			(interactive)
			(cond ((= (char-after) ?\( )
						 (call-interactively 'sp-kill-sexp))
						((= (char-before) ?\) )
						 (call-interactively 'sp-backward-kill-sexp)))
			)

		(defun attila-sp-unwrap-sexp ()
			(interactive)
			(cond ((= (char-after) ?\( )
						 (call-interactively 'sp-unwrap-sexp))
						((= (char-before) ?\) )
						 (call-interactively 'sp-backward-unwrap-sexp)))
			)

		:config
		;; Sane defaults for smartparens, like do not double ' for lisp dialects
		(require 'smartparens-config)
		(smartparens-global-mode t)
		:bind
		(("<insert> 9 k" . attila-sp-kill-sexp)
		 ("<insert> 9 u" . attila-sp-unwrap-sexp)))
#+end_src

#+RESULTS:
: attila-sp-unwrap-sexp

*** Up or down case toggle

#+begin_src emacs-lisp :tangle yes

(global-set-key (kbd "H-n") 'attila/up-down-case-toggle)

#+end_src

#+RESULTS:
: attila/up-down-case-toggle

*** Auto-completion with company
#+begin_src emacs-lisp :tangle yes

	(use-package company
		:straight t
		:defer t
		:diminish company-mode
		:init
		(add-hook 'after-init-hook 'global-company-mode)
		:config
		;; dabbrev should not downcase it completions
		(setq company-dabbrev-downcase nil)
		;; dabbrev by default only looks for
		(setq company-dabbrev-char-regexp "[a-zA-Z0-9._]")
		;; Cycle throught competiton candidates
		(setq company-selection-wrap-around t)
		;; sort candidate according to their occurrance in the current buffer and back-end importance if available
		(setq company-transformers '(company-sort-by-occurrence
																	company-sort-by-backend-importance))
		:bind
		(:map company-active-map
					("C-i" . 'company-select-previous)
					("C-k" . 'company-select-next)))
#+end_src

#+RESULTS:
: company-select-next

*** Company shows help popups

#+begin_src emacs-lisp :tangle yes

	(use-package company-quickhelp
		:straight t
		:config
		(company-quickhelp-mode))

#+end_src

#+RESULTS:
: t

*** Yasnippet

**** Data

#+begin_src emacs-lisp :tangle yes
	(defvar my/yas-data-og-types '("website"
																"article"
																"book"
																"music.song"
																"music.album"
																"music.playlist"
																"music.radio_station"
																"video.movie"
																"video.episode"
																"video.tv_show"
																))

	(defvar my/yas-authors '("Analogika Kft."
													 "Analogika Ltd."
													 "Hacker Space P√©cs"
													 "Attila V. Moln√°r"))
#+end_src

**** Core

#+begin_src emacs-lisp :tangle yes
	(use-package yasnippet
		:straight t
		:diminish yas-minor-mode
		:demand t
		:config
		(yas-global-mode 1)
		(setq yas-snippet-dirs
		'("~/.emacs.d/snippets/"))

		;; keybinding for navigating between yas fields are only used inside of a snippet,
		;; outside they would be useless so I made functions, which navigate inside a snippet
		;; However outside navigate between symbolic expression
		(defun my/yas-next-field-or-forward-sexp ()
			"Try to jump to next yas field if not in a snippet jump forward a symbolic expression"
			(interactive)
			(condition-case err
		(yas-next-field)
				(error
				 (call-interactively 'attila-smart-move-beginning-of-line))))

		(defun my/yas-previous-field-or-backward-sexp ()
			"Try to jump to next yas field if not in a snippet jump forward a symbolic expression"
			(interactive)
			(condition-case err
		(yas-prev-field)
				(error
				 (call-interactively 'move-end-of-line))))

		(define-key yas-minor-mode-map (kbd "C-j") 'my/yas-next-field-or-forward-sexp)
		(define-key yas-minor-mode-map (kbd "C-l") 'my/yas-previous-field-or-backward-sexp)
		(define-key yas-minor-mode-map (kbd "<tab>") nil)
		(define-key yas-minor-mode-map (kbd "TAB") nil)
		(define-key yas-minor-mode-map (kbd "M-e") 'yas/expand)
		:bind
		(("<insert> e a" . yas-reload-all))
		(:map snippet-mode-map
					("<insert> j t" . yas-tryout-snippet)))
#+end_src

#+RESULTS:
: yas-tryout-snippet

**** Yas Helper functions

#+begin_src emacs-lisp :tangle yes

	(defun attila/yas-selected-text-replace ()
		"Replace selected via yasnippet"
		;; (delete-region (mark) (point))
		;; Insert selected text
		(if (char-or-string-p yas/selected-text)
				(progn
		(if (< (point) (mark))
				(progn
					(search-forward yas/selected-text)
					(replace-match "")))
		(if (> (point) (mark))
				(progn
					(search-backward yas/selected-text)
					(replace-match ""))))))


#+end_src

#+RESULTS:
: attila/yas-selected-text-replace

*** Smart insertions
**** Path insertions

#+begin_src emacs-lisp :tangle yes

	(defun attila/insert-file-name-relative (filename)
			"Insert relative path to FILENAME into buffer after point"
			;; Based on insert-file in Emacs -- ashawley 20080926
			(interactive "*fInsert file name: \n")
			(insert (file-relative-name filename)))

	(defun attila/insert-file-name-absolute (filename)
			"Insert absolute path FILENAME into buffer after point."
			;; Based on insert-file in Emacs -- ashawley 20080926
			(interactive "*fInsert file name: \n")
			 (insert (expand-file-name filename)))

	(global-set-key (kbd "<insert> i p r") 'attila/insert-file-name-relative)
	(global-set-key (kbd "<insert> i p a") 'attila/insert-file-name-absolute)

#+end_src

#+RESULTS:
: attila/insert-file-name-absolute

*** Line editing
**** Duplicate line above/below

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> l i") 'attila/line-duplicate-above)
	(global-set-key (kbd "<insert> l k") 'attila/line-duplicate-below)
#+end_src

#+RESULTS:
: attila/line-duplicate-below

*** Spell checking

#+begin_src emacs-lisp :tangle yes

	(use-package flyspell
		:straight t
		:defer t
		:commands
		flyspell-mode
		flyspell-prog-mode
		attila/flyspell-mode
		:diminish flyspell-mode "‚úé"
		:config
		(defun attila/flyspell-mode ()
			(interactive)
			(if (derived-mode-p 'prog-mode)
					(flyspell-prog-mode)
				(flyspell-mode)))
		;; do not issue errors if not asked
		(setq flyspell-issue-message-flag nil))

	(use-package helm-flyspell
		:straight t
		:commands
		attila/flyspell-check-word-at-point
		attila/flyspell-check-next-highlighted-word
		:config
		(defun attila/flyspell-check-word-at-point ()
			"Check word at point with helm-flyspell"
			(interactive)
			(let ((misspelled-word (car (flyspell-get-word))))
			(helm-flyspell-correct)
			(message (concat misspelled-word " --> " (car (flyspell-get-word))))))

		(defun attila/flyspell-check-next-highlighted-word ()
		"Custom function to spell check next highlighted word"
		(interactive)
		(flyspell-goto-next-error)
		(attila/flyspell-check-word-at-point)))


#+end_src

#+RESULTS:
: t

*** Bookmarking

#+begin_src emacs-lisp :tangle yes

	(use-package bm
					 :ensure t
					 :demand t
					 :straight t
					 :init
					 ;; restore on load (even before you require bm)
					 (setq bm-restore-repository-on-load t)

					 :config
					 ;; Allow cross-buffer 'next'
					 (setq bm-cycle-all-buffers t)

					 (setq bm-show-annotations t)

					 ;; where to store persistant files
					 (setq bm-repository-file "~/.emacs.d/bookmark-repository")

					 ;; save bookmarks
					 (setq-default bm-buffer-persistence t)

					 ;; Loading the repository from file when on start up.
					 (add-hook' after-init-hook 'bm-repository-load)

					 ;; Restoring bookmarks when on file find.
					 (add-hook 'find-file-hooks 'bm-buffer-restore)

					 ;; Saving bookmarks
					 (add-hook 'kill-buffer-hook #'bm-buffer-save)

					 ;; Saving the repository to file when on exit.
					 ;; kill-buffer-hook is not called when Emacs is killed, so we
					 ;; must save all bookmarks first.
					 (add-hook 'kill-emacs-hook #'(lambda nil
																						(bm-buffer-save-all)
																						(bm-repository-save)))

					 ;; The `after-save-hook' is not necessary to use to achieve persistence,
					 ;; but it makes the bookmark data in repository more in sync with the file
					 ;; state.
					 (add-hook 'after-save-hook #'bm-buffer-save)

					 ;; Restoring bookmarks
					 (add-hook 'find-file-hooks   #'bm-buffer-restore)
					 (add-hook 'after-revert-hook #'bm-buffer-restore)

					 ;; The `after-revert-hook' is not necessary to use to achieve persistence,
					 ;; but it makes the bookmark data in repository more in sync with the file
					 ;; state. This hook might cause trouble when using packages
					 ;; that automatically reverts the buffer (like vc after a check-in).
					 ;; This can easily be avoided if the package provides a hook that is
					 ;; called before the buffer is reverted (like `vc-before-checkin-hook').
					 ;; Then new bookmarks can be saved before the buffer is reverted.
					 ;; Make sure bookmarks is saved before check-in (and revert-buffer)
					 (add-hook 'vc-before-checkin-hook #'bm-buffer-save)


					 :bind (("<insert> a l" . bm-next)
									("<insert> a j" . bm-previous)
									("<insert> a t" . bm-toggle)
									("<insert> a s" . bm-show-all)
									("<insert> a a" . bm-show-annotations)

									)
					 )

#+end_src

#+RESULTS:
: bm-show-annotations

** Tools
*** package search

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> 1 p") 'package-list-packages)

#+end_src

#+RESULTS:
: package-list-packages

*** Sync shell command

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> 2 2") 'shell-command)

#+end_src

#+RESULTS:
: shell-command

*** Version control
**** Magit
#+begin_src emacs-lisp :tangle yes

	(use-package magit
		:straight t
		:config
		(defun my/magit-display-noselect-toggle ()
		"Display magit buffer but do not select window"
		(interactive)(if (equal magit-display-buffer-noselect nil)
				 (setq magit-display-buffer-noselect t) (setq magit-display-buffer-noselect nil)))
		:bind
		(("<insert> v v" . magit-status)
		 ("<insert> v l" . magit-log-buffer-file)
		 ("<insert> v i" . magit-init)
		 ("<insert> v c" . magit-clone)
		 ("<insert> v f" . magit-find-file)
		 ("<insert> v b" . magit-branch-popup)
		 ("<insert> v p" . magit-push-popup))
		:bind
		(:map magit-mode-map
					("<tab>" . magit-section-toggle)
)
		(:map magit-log-mode-map
					("s-<f3>" . magit-display-noselect-toggle)))

#+end_src

#+RESULTS:
: magit-display-noselect-toggle

**** Git gutter

#+begin_src emacs-lisp :tangle yes

	(use-package git-gutter
		:straight t
		:defer t
		:diminish git-gutter-mode "‚úì"
		:config

		(defun my/git-gutter:batch-revert-hunk (beg end)
			(interactive
			 (if (use-region-p)
			 (list (region-beginning) (region-end))
			 (list (point) (point-max))))
			(loop t
				(call-interactively 'git-gutter:next-hunk)
				(when (> (point) end)
					(return))
				(call-interactively 'git-gutter:revert-hunk)))

		:bind
		(("<insert> v r" . git-gutter:revert-hunk)
		 ("<insert> v a a" . global-git-gutter-mode)
		 ("<insert> v a p" . git-gutter:popup-hunk)
		 ("<insert> v a s" . git-gutter:statistic)
		 ("<insert> v h p" . git-gutter:previous-hunk)
		 ("<insert> v h n" . git-gutter:next-hunk)
		 ("s-[" . git-gutter:previous-hunk)
		 ("s-]" . git-gutter:next-hunk)
		 )
		)

#+end_src
**** Generati links to remote git repositories

#+begin_src emacs-lisp :tangle yes

	(use-package git-link
		:straight t
		:bind
		("<insert> v u u" . git-link)
		("<insert> v u c" . git-link-commit)
		("<insert> v u h" . git-link-homepage))

#+end_src

#+RESULTS:
: git-link-homepage

*** Commint mode
**** Commint mode bindings

#+begin_src emacs-lisp :tangle yes
(define-key comint-mode-map (kbd "M-i") 'comint-previous-input)
(define-key comint-mode-map (kbd "M-k") 'comint-next-input)
#+end_src

#+RESULTS:
: comint-next-input

*** File management
**** Edit dired as normal buffer

#+begin_src emacs-lisp :tangle yes

(define-key dired-mode-map (kbd "<insert> j e") 'wdired-change-to-wdired-mode)

#+end_src

**** Toggle dired listing modes

#+begin_src emacs-lisp :tangle yes
	(require 'dired)

	(setq dired-listing-switches "-lh")
	(setq attila/dired-switch-list '("-lh" "-lha" ""))
	(setq attila/dired-switch-list-counter 0)

	(defun attila/dired-toggle-listing-switches ()
		(interactive)
		(setq attila/dired-switch-list-counter
					(mod
					 (+ 1 attila/dired-switch-list-counter)
					 (length attila/dired-switch-list)))
		(setq dired-listing-switches
					(nth attila/dired-switch-list-counter
							 attila/dired-switch-list))
		(when (eq major-mode 'dired-mode)
			(let ((dir dired-directory))
				(kill-buffer (buffer-name))
				(dired dir))))

	(define-key dired-mode-map (kbd ".") 'attila/dired-toggle-listing-switches)
#+end_src
**** Allow recursive dired deletes

#+begin_src emacs-lisp :tangle yes
  (setq dired-recursive-deletes  +1)
#+end_src

#+RESULTS:
: 1

**** Act on multiple files from differen dirs

Source: https://www.masteringemacs.org/article/working-multiple-files-dired

#+begin_src emacs-lisp :tangle yes

	(require 'find-dired)
	(setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
	(unbind-key (kbd "s") dired-mode-map)
	(define-key dired-mode-map (kbd "s f") 'find-name-dired)

#+end_src

#+RESULTS:
: (-print0 | xargs -0 ls -ld . -ld)

**** Automaticly show file contents

For bindigs ceck hydra config

#+begin_src emacs-lisp :tangle yes

	(use-package peep-dired
		:straight t
		:defer t
		:commands peep-dired
		:config
		;; Close peeped buffers on mode end
		(setq peep-dired-cleanup-on-disable t)
		;; Activate peep ind peeped directories
		(setq peep-dired-enable-on-directories t)
		;; ignore these extensions
		(setq peep-dired-ignored-extensions '("mkv" "iso" "mp4")))

#+end_src

#+RESULTS:
: t

*** Reading log files

#+begin_src emacs-lisp :tangle yes :results none

	(use-package logview
		:straight t
		:mode
		("\\.log\\'")
		:bind
		(:map logview-mode-map
					("i" . logview-previous-entry)
					("k" . logview-next-entry)
					("l" . 'scroll-up-command)
					("j" . 'scroll-down-command)
					))

#+end_src

*** Multimedia
**** Remove metadata from .srt files

#+begin_src emacs-lisp :tangle yes
	(require 'srecode/srt-mode)

		(defun attila/srt-remove-time ()
			(interactive)
			(while t
				(beginning-of-buffer)
				(search-forward "-->")
				(next-line)
				(beginning-of-line)
				(call-interactively 'set-mark-command)
				(previous-line 2)
				(beginning-of-line)
				(kill-region (region-beginning) (region-end))))

	(define-key srecode-template-mode-map (kbd "<insert> j t") 'attila/srt-remove-time)

#+end_src

#+RESULTS:
: attila/srt-remove-time

*** Debugger

#+begin_src emacs-lisp :tangle yes

(use-package realgud
	:straight t
	:config
	(setq realgud:ipdb-command-name "ipdb")
	:bind
	;; Associate source buffers to command buffers
	("<insert> / a" . realgud-short-key-mode))

#+end_src

#+RESULTS:
: realgud-short-key-mode

*** Network
**** Pcap mode
#+begin_src emacs-lisp :tangle yes

(use-package pcap-mode
	:straight t)

#+end_src

**** Execute elisp function on all files in the git working tree

#+begin_src emacs-lisp :tangle yes
(defun tarsius/mapc-tracked-files (fn)
  (magit-with-toplevel
    (mapc (lambda (file)
            (with-current-buffer
                (find-file-noselect file)
              (save-excursion
                (goto-char (point-min))
                (funcall fn))))
          (magit-list-files))))

(defun attila/magit-execute-function-in-working-tree ()
	(interactive)
  (tarsius/mapc-tracked-files
	 (lambda () (message buffer-file-name))))
#+end_src
** Information gathering
*** Default browser

#+begin_src emacs-lisp :tangle yes

  (setq gnus-button-url 'browse-url-generic
        browse-url-browser-function gnus-button-url
        browse-url-generic-program
        (attila/get-first-true
         '("chromium" "vivaldi" "google-chrome-stable" "firefox")
         (function (lambda (command)
                     (if (executable-find command)
                         command
                       nil)))))

#+end_src

*** Web search with searx or google

#+begin_src emacs-lisp :tangle yes

	(use-package helm-google
		:straight t
		:bind
		(("<insert> h g" . helm-google-searx)))

#+end_src
*** man

Break lines when displaying man pages.

#+begin_src emacs-lisp :tangle yes

		(use-package man
			:straight t
			:commands
			helm-man-woman)

#+end_src

#+RESULTS:

*** info pages

#+begin_src emacs-lisp :tangle yes

  (use-package info-buffer
    :straight t
    :defer 4
    :bind (("<insert> h i" . info-buffer)))

#+end_src

*** Offline documentation with dash

#+begin_src emacs-lisp :tangle yes

	(use-package helm-dash
		:straight t
		:config
		(setq helm-dash-docsets-path "~/data/dash-docsets/")
		(setq  helm-dash-browser-func 'browse-url)
		:bind(
					(("<insert> h d d" . helm-dash)
					 ("<insert> h d i" . helm-dash-install-docset)
					 ("<insert> h d u" . helm-dash-update-docset)
					 ("<insert> h d a" . helm-dash-activate-docset)
					 ("<insert> h d k" . helm-dash-deactivate-docset))))

#+end_src
*** Hotkey info
**** Hotkey hinting

#+begin_src emacs-lisp :tangle yes

	(use-package which-key
		:straight t
		:demand t
		:config
		(which-key-setup-side-window-right-bottom)
		(which-key-mode t)
		;; Prefix labels
		(which-key-add-key-based-replacements
			"<insert> SPC" "Editing hydra"
			"<insert> 1" "Emacs internal tools"
			"<insert> 2" "applications"
			"<insert> 2 s" "System monitoring"
			"<insert> 2 d" "Database clients"
			"<insert> 3" "Window management"
			"<insert> s" "Search tools"
			"<insert> b" "Buffer management"
			"<insert> p" "Project management"
			"<insert> a" "Annotation tool"
			"<insert> e" "Snippet tools"
			"<insert> d" "Debuging tools"
			"<insert> i" "Insertion tools"
			"<insert> l" "Line-edit tools"
			"<insert> r" "Refactoring tools"
			"<insert> v" "Version control"
			"<insert> v a" "analyzing tools"
			"<insert> x" "I/O actions"
			"<insert> j" "Major mode actions"
			"<insert> ;" "Selection tools"
			"<insert> h" "Help")
		:bind
		("<insert> h m " . which-key-show-major-mode))

#+end_src

#+RESULTS:
: which-key-show-major-mode

 #+begin_src emacs-lisp :tangle no

	 (use-package guide-key
		 :straight t
		 :diminish guide-key-mode
		 :config
		 (setq guide-key/guide-key-sequence t)
		 (setq guide-key/recursive-key-sequence-flag t)
		 (setq guide-key/idle-delay 0.5)
		 (guide-key-mode 1))

 #+end_src

 #+RESULTS:
 : t

**** Hotkey exploration

#+begin_src emacs-lisp :tangle yes

	(use-package helm-descbinds
		:straight t
		:commands helm-descbinds
		:diminish helm-descbinds-mode
		:bind
		("<insert> h k" . helm-descbinds))

#+end_src

#+RESULTS:
: helm-descbinds-mode

** Programming
*** Elisp
**** Evaluation
#+begin_src emacs-lisp :tangle yes

	(defun attila/lisp-eval-region-or-buffer ()
		"Eval region if selected, otherwise eval the buffer"
		(interactive)
		(if (use-region-p)
				(call-interactively 'eval-region)
			(call-interactively 'eval-buffer)))

	(define-key lisp-mode-map (kbd "<insert> j e") 'attila/lisp-eval-region-or-buffer)
	(define-key emacs-lisp-mode-map (kbd "<insert> j e r") 'attila/lisp-eval-region-or-buffer)

#+end_src

#+RESULTS:

**** Edebug

#+begin_src emacs-lisp :tangle yes

	(define-key emacs-lisp-mode-map (kbd "<insert> d f") 'edebug-defun)
	(define-key lisp-mode-map (kbd "<insert> d f") 'edebug-defun)
	(define-key lisp-mode-map (kbd "<insert> d i") 'edebug-mode)
	(define-key emacs-lisp-mode-map (kbd "<insert> d i") 'edebug-mode)

#+end_src

#+RESULTS:
: edebug-stop

**** Suggest functions from example input and output

#+begin_src emacs-lisp :tangle

		(use-package suggest
			:straight t
			:bind
			("<insert> h e s" . suggest))

#+end_src

#+RESULTS:
: suggest

*** Org mode
**** Installation workaround

Recent org mode cannot install org-mode directly, because it needs custom build with make. This solution was borrowed from [[https:github.com/raxod502/straight.el#installing-org-with-straightel][here]].

#+begin_src emacs-lisp :tangle yes

	(require 'subr-x)
	(straight-use-package 'git)

	(defun org-git-version ()
		"The Git version of org-mode.
	Inserted by installing org-mode or when a release is made."
		(require 'git)
		(let ((git-repo (expand-file-name
										 "straight/repos/org/" user-emacs-directory)))
			(string-trim
			 (git-run "describe"
								"--match=release\*"
								"--abbrev=6"
								"HEAD"))))

	(defun org-release ()
		"The release version of org-mode.
	Inserted by installing org-mode or when a release is made."
		(require 'git)
		(let ((git-repo (expand-file-name
										 "straight/repos/org/" user-emacs-directory)))
			(string-trim
			 (string-remove-prefix
				"release_"
				(git-run "describe"
								 "--match=release\*"
								 "--abbrev=0"
								 "HEAD")))))

	(provide 'org-version)

	;; (straight-use-package 'org) ;; or org-plus-contrib if desired

#+end_src

**** Org core

#+begin_src emacs-lisp :tangle yes

	(use-package org
		:straight t
		:defer t
		:commands
		org-annotate-file
		org-annotate-file-find-storage-file
		:config
		(org-load-modules-maybe t)
		(setq org-modules (-concat org-modules '(org-annotate-file) ))
		;; Do not ask confirmation for evaluating Elisp blocks
		(defun my-org-confirm-babel-evaluate (lang body)
			(not (member lang '("emacs-lisp"))))
		(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
		(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)
		;; Use spaces instead of tabs in source code blocks
		(setq org-src-tab-acts-natively t)
		(setq org-src-preserve-indentation t)

		(require 'ansi-color)

		(defun org-capture-file-find-storage-file ()
		(interactive)
		(find-file "~/.notes"))
		;; Prefix labels
		(which-key-add-major-mode-key-based-replacements 'org-mode
		"<insert> j e" "Build/Eval/Export tools"
		"<insert> j s" "Special block management"
		"<insert> j i" "Insertion tools"
		"<insert> j v" "Visualization options"
		"<insert> j t" "Time tracking tools")
		:bind
		(:map org-mode-map
					;; headlines
					("<insert> j g" . org-global-cycle)
					("<insert> j e t" . org-babel-tangle)
					("<insert> j e m" . org-md-export-to-markdown)
					("<insert> j e l" . org-latex-export-to-latex)
					("<insert> j e p" . 'org-latex-export-to-pdf)
					("<insert> j i t" . org-time-stamp)
					("<insert> j i h" . org-babel-insert-header-arg)
					("<insert> j i l" .  org-insert-link)
					("<insert> j i p" . org-set-property)
					;; Loging work time
					("<insert> j o i" . org-clock-in)
					("<insert> j o o" . org-clock-out)
					;; Specials
					("<insert> j s s" . org-edit-special)
					("<insert> j s C-w" . org-cut-special)
					("<insert> j s M-w" . org-copy-special)
					("<insert> j s C-y" . org-paste-special)
					;; tables
					("<insert> j t j" . org-table-previous-field)
					("<insert> j t l" . org-table-next-field)
					("<insert> j t f" . org-table-edit-field)
					("<insert> j t d f" . org-table-blank-field)
					("<insert> j t a" . org-table-align)
					;; table edit
					("<insert> j t C-j" . org-table-move-column-left)
					("<insert> j t C-l" . org-table-move-column-right)
					("<insert> j t C-i" . org-table-move-row-up)
					("<insert> j t C-k" . org-table-move-row-down)
					("<insert> j t d r" . org-table-kill-row)
					("<insert> j t c r" . org-table-insert-row)
					("<insert> j t c c" . org-table-insert-column)
					("<insert> j t c l" . org-table-insert-hline)
					("<insert> j t s" . org-table-sort-lines)
					("<insert> j t M-w" . org-table-copy-region)
					("<insert> j t C-W" . org-table-cut-region)
					("<insert> j t C-y" . org-table-paste-rectangle)
					;; table analitics
					("<insert> j t +" . org-table-sum)
					("<insert> j t b" . org-table-import)
					("<insert> j t e" . org-table-export)

					;; Visualization
					("<insert> j v l" . org-toggle-link-display)
					("<insert> j n n" . org-narrow-to-element)
					("<insert> j n s" . org-narrow-to-subtree)
					("<insert> j n e" . org-narrow-to-element)
					("<insert> j n w" . widen)
					;; Annotation
					("<insert> a a" . org-annotate-file)
					("<insert> a f" . org-annotate-file-find-storage-file)
					("<insert> a c" . org-capture)
		(:map org-src-mode-map
					("C-c C-c" . 'org-edit-src-exit))))


#+end_src

#+RESULTS:
: org-edit-src-exit

**** Hooks
**** Org global properties
***** Latex header

#+begin_src emacs-lisp :tangle yes

;; (setq org-global-properties '(("LATEX_HEADER" . "\\usepackage{hyperref} \\usepackage{tcolorbox} \\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}")))
;; (add-to-list 'org-global-properties '("latex_header" . "\\usepackage{hyperref} \\usepackage{tcolorbox} \\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}"))

(setq org-latex-classes '(("article" "\\documentclass[11pt]{article}
\\usepackage{hyperref}
\\usepackage{tcolorbox}
\\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue}"

	("\\section{%s}" . "\\section*{%s}")
	("\\subsection{%s}" . "\\subsection*{%s}")
	("\\subsubsection{%s}" . "\\subsubsection*{%s}")
	("\\paragraph{%s}" . "\\paragraph*{%s}")
	("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
 ("report" "\\documentclass[11pt]{report}"
	("\\part{%s}" . "\\part*{%s}")
	("\\chapter{%s}" . "\\chapter*{%s}")
	("\\section{%s}" . "\\section*{%s}")
	("\\subsection{%s}" . "\\subsection*{%s}")
	("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
 ("book" "\\documentclass[11pt]{book}"
	("\\part{%s}" . "\\part*{%s}")
	("\\chapter{%s}" . "\\chapter*{%s}")
	("\\section{%s}" . "\\section*{%s}")
	("\\subsection{%s}" . "\\subsection*{%s}")
	("\\subsubsection{%s}" . "\\subsubsection*{%s}"))))
#+end_src

#+RESULTS:
| article | \documentclass[11pt]{article} |

**** Org helpers
***** Org list to flat list
#+begin_src emacs-lisp :tangle yes

	(defun attila/org-list-to-flat-elisp-list (value path-list)
		(let ((head (car value))
					(tail (cdr value)))
			(reverse
			 (cond
				((not head)
				 path-list)
				((string-or-null-p head)
				 (attila/org-list-elisp-list tail (add-to-list 'path-list head)))
				((symbolp head)
				 (attila/org-list-elisp-list tail path-list))
				((sequencep head)
				 (attila/org-list-elisp-list tail (attila/org-list-elisp-list head path-list)))))))

#+end_src
***** Org list to path list

#+begin_src emacs-lisp :tangle yes
	(defun attila/org-list-to-path-list (org-list)
			(let ((my-paths))
			(defun attila/org-list-to-elisp-list (value dir-list)
		(let ((head (car value))
					(tail (cdr value)))
			 (cond
				((not head)
				 (mapconcat 'identity (reverse dir-list) "/"))
				((string-or-null-p head)
				 (attila/org-list-to-elisp-list tail (add-to-list 'dir-list head)))
				((symbolp head)
				 (attila/org-list-to-elisp-list tail dir-list))
				((sequencep head)
				 (add-to-list 'my-paths (attila/org-list-to-elisp-list head dir-list))
				 (attila/org-list-to-elisp-list tail dir-list)
				 ))))

			(attila/org-list-to-elisp-list org-list '())
			my-paths))
#+end_src

#+RESULTS:
: attila/org-list-to-path-list
**** Org customized source blocks
***** Dockerfile

#+begin_src emacs-lisp :tangle yes
(defun org-babel-execute:dockerfile (body params)
  "Execute a block of Foma code with org-babel."
  (message "executing Foma source code block")
  (org-babel-eval "dockerfile" body))
#+end_src

#+RESULTS:
: org-babel-execute:dockerfile

**** Org headline search with org-rifle

#+begin_src emacs-lisp :tangle yes

	(use-package helm-org-rifle
		:straight t
		:demand t
		:commands helm-org-rifle-current-buffer
		:bind
		(:map org-mode-map
					("<insert> s m m" . helm-org-rifle-current-buffer)))

#+end_src

#+RESULTS:
: helm-org-rifle-current-buffer

**** Reveal.js

#+begin_src emacs-lisp :tangle yes
(load "~/.emacs.d/extensions/org-reveal/ox-reveal.el")
#+end_src

*** Web
**** Web mode for HTML and CSS

#+begin_src emacs-lisp :tangle yes :results output

	(use-package web-mode
		:straight t
		:defer t
		:mode
		("\\.phtml\\'"	"\\.tpl\\.php\\'"	"\\.[agj]sp\\'"	"\\.as[cp]x\\'"	"\\.erb\\'"	"\\.mustache\\'"	"\\.djhtml\\'"	"\\.html\\'"	"\\.css\\'"	"\\.svg\\'"	"\\.liq\\'")
		:config

		(add-hook 'web-mode-hook
							(lambda ()
								(setq-local company-backends
														(append '((company-css
																			 :separate
																			 company-web-html
																			 :separate
																			 company-dabbrev))))))
		;; turn on highlight on current element and column
		(setq web-mode-enable-current-element-highlight nil)
		(setq web-mode-enable-current-column-highlight t)
		;; set indentation
		(setq web-mode-markup-indent-offset 2)
		(setq web-mode-code-indent-offset 2)
		(setq web-mode-css-indent-offset 2)
		(add-hook 'web-mode-hook (lambda ()
															 (set (make-local-variable
																		 'company-backends)
																		'(company-web-html
																			company-css
																			company-files))
															 (company-mode t)
															 (emmet-mode t)))
		;;web-mode snippets
		(setq web-mode-extra-snippets
					'(("djhtml" . (("toto" . ("<% toto | %>\n\n<% end %>"))))
						("php" . (("dowhile" . ("<?php do { ?>\n\n<?php } while (|); ?>"))
											("debug" . ("<?php error_log(__LINE__); ?>")))))))
#+end_src

#+RESULTS:

**** JavaScript
***** js2 mode

#+begin_src emacs-lisp :tangle yes

	(use-package js2-mode
		:straight t
		:defer t
		:init
		(add-to-list 'auto-mode-alist '("\\.js\\'" . js2-mode))
		:config
		;; indentation basis
		(setq js2-basic-offset 2)
		;; Ignore preprocessor directives for node.js files
		(setq js2-skip-preprocessor-directives t))

#+end_src

#+RESULTS:
: ~/.emacs.d/.eslintrc.yml

***** JS linting

Lint JS files on save when ".eslintrc.yml" is in the project root.

#+begin_src emacs-lisp :tangle yes

	(use-package eslint-fix
		:straight t
		:commands eslint-fix
		:init
		;; automaticly fix styling with eslint on save
		(add-hook
		 'js2-mode-hook
		 (lambda ()
			 (when (file-readable-p (concat (vc-root-dir) ".eslintrc.yml"))
				 (add-hook 'after-save-hook 'eslint-fix nil t)))))

#+end_src

#+RESULTS:

***** npm install from require statements

#+begin_src emacs-lisp :tangle no

	(defun my/npm-install-required (save-flag)
		(interactive
		 (list
			(completing-read "Choose one: " '("--save" "--save-dev" ""))))
				(let* ((beg (region-beginning))
							 (end (region-end))
							 (selection (buffer-substring-no-properties beg end)))
					(->> selection
							 (s-match-strings-all "['\"].*['\"]")
							 (mapcar 'car)
							 (s-join " ")
							 (s-concat "npm i " save-flag " ")
							 (async-shell-command))))

	(define-key js2-mode-map (kbd "<insert> j i") 'my/npm-install-required)

#+end_src

#+RESULTS:
: my/npm-install-required

**** JSON
***** Bindigs
#+begin_src emacs-lisp :tangle yes

(use-package json-mode
	:straight t
	:config
	(require 'json-mode)
	:bind
	(:map json-mode-map
				("<insert> j v p" . json-pretty-print-buffer)
				("<insert> j v o" . json-pretty-print-ordered)))

#+end_src

#+RESULTS:
: json-pretty-print-buffer-ordered

***** Navigator

#+begin_src emacs-lisp :tangle yes
(require 'json-mode)
(use-package json-navigator
	:straight t
	:bind
	(:map json-mode-map
				("<insert> j j" . 'json-navigator-navigate-after-point)))

#+end_src

#+RESULTS:
: t

**** Indium JS REPL

#+begin_src emacs-lisp :tangle no

	(use-package indium
		:straight t
		:defer t
		:init
		(add-hook 'js2-mode-hook #'indium-interaction-mode)
		(add-hook 'js2-mode-hook
							(lambda ()
								(setq-local
								 company-backends
								 (append '((company-indium-repl
														:separate
														company-dabbrev))))))
		:config
		(defun attila/indium-eval-region-or-buffer ()
			"Eval region if selected, otherwise eval the buffer"
			(interactive)
			(if (use-region-p)
					(call-interactively 'indium-eval-region)
				(call-interactively 'indium-eval-buffer)))
		:bind
		(:map js2-mode-map
					("<insert> j c c" . indium-connect-to-chrome)
					("<insert> j c n" . indium-connect-to-nodejs)
					("<insert> j e e" . attila/indium-eval-region-or-buffer)
					("<insert> j r" . indium-reload)))

#+end_src

#+RESULTS:
: indium-reload

**** LESS

#+begin_src emacs-lisp :tangle yes

	(use-package less-css-mode
		:straight t
		:defer t
		:mode
		("\\.less\\'"))

#+end_src

#+RESULTS:
**** WebKit Color picker

#+begin_src emacs-lisp :tangle yes
  (when (>= emacs-major-version 26)
          (use-package webkit-color-picker
    :ensure t
    :straight t
    :bind
          (("<insert> 2 p" . webkit-color-picker-show))))
#+end_src

**** Org Babel Ansible

#+begin_src emacs-lisp :tangle yes



#+end_src
*** Shell
**** Shell script mode
#+begin_src emacs-lisp :tangle yes

	(add-to-list 'magic-mode-alist '("^#![/binuserahz]\\{7,11\\}" "#!/bin/bash" . shell-script-mode))
	(add-to-list 'magic-mode-alist '("^#![/binusernv]\\{7,13\\}\\ ?[bashz]\\{2,4\\}" . shell-script-mode))
	(add-to-list 'auto-mode-alist '("\\.?bashrc" . shell-script-mode))
	(add-to-list 'auto-mode-alist '("\\.?zshrc" . shell-script-mode))

	(use-package company-shell
		:straight t
		:defer t
		:init
		(add-hook
		 'shell-mode-hook
		 (lambda ()
			 (setq-local company-backend 'company-shell))))

#+end_src

#+RESULTS:
| lambda | nil | (setq-local company-backend (quote company-shell)) |

**** Eshell
***** Multiple eshell session

#+begin_src emacs-lisp :tangle yes

	(defun attila/eshell-new(shell-name)
		"Open a new instance of eshell."
		(interactive (list (read-string "Shell Name: ")))
		(setq eshell-buffer-name (concat "*" shell-name "-eshell*"))
		(eshell 'N))

	(global-set-key (kbd "<insert> 2 e") 'attila/eshell-new)

#+end_src

#+RESULTS:
: attila/eshell-new

***** Fish-shell like autosuggestions

#+begin_src emacs-lisp :tangle yes

		(use-package esh-autosuggest
			:straight t
			:hook (eshell-mode . esh-autosuggest-mode)
			;; If you have use-package-hook-name-suffix set to nil, uncomment and use the
			;; line below instead:
			;; :hook (eshell-mode-hook . esh-autosuggest-mode)
			:ensure t
			:config
			(defun setup-eshell-helm-completion ()
				(define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete))

			(add-hook 'eshell-mode-hook #'setup-eshell-helm-completion))


#+end_src

#+RESULTS:
| setup-eshell-helm-completion | esh-autosuggest-mode |
***** Prompt git info

It would be also [[https://github.com/kaihaosw/eshell-prompt-extras/tree/1d8825dcc005b488c6366d0b3015fc6686194eea#usage][possible]] to promt info about python virtual envs.

#+begin_src emacs-lisp :tangle yes

	(use-package eshell-prompt-extras
		:straight t
		:ensure t
		:config
		(add-hook 'eshell-mode-hook
							(lambda ()
								(require 'eshell-prompt-extras)
								(setq eshell-highlight-prompt nil
											eshell-prompt-function 'epe-theme-lambda))))

#+end_src

#+RESULTS:
: t
***** Eshell eldoc and quick man search support

#+begin_src emacs-lisp :tangle yes

	(use-package esh-help
		:straight t)

	(require 'esh-help)
	(setup-esh-help-eldoc)  ;; To use eldoc in Eshell

	(add-hook 'eshell-mode-hook
						(lambda ()
							(define-key eshell-mode-map (kbd "<insert> h h") 'esh-help-run-help)))

#+end_src

#+RESULTS:
| (lambda nil (define-key eshell-mode-map (kbd <insert> h h) (quote esh-help-run-help))) | #[nil \301\300!\210\302\211\207 [eldoc-documentation-function make-local-variable esh-help-eldoc-command] 2] | (lambda nil (setup-esh-help-eldoc)) | (lambda nil (require (quote eshell-prompt-extras)) (setq eshell-highlight-prompt nil eshell-prompt-function (quote epe-theme-lambda))) | (lambda nil (autoload (quote epe-theme-lambda) eshell-prompt-extras) (setq eshell-highlight-prompt nil eshell-prompt-function (quote epe-theme-lambda))) | eshell-prompt-extras | setup-eshell-helm-completion | esh-autosuggest-mode |

*** python
**** Basic python-mode config

#+begin_src emacs-lisp :tangle yes

(require 'python)

(defun attila/run-python ()
	(interactive)
	(if (buffer-live-p (get-buffer "*Python*"))
			(progn
				(kill-buffer "*Python*")
				(call-interactively 'run-python))
		(call-interactively 'run-python)))


(define-key python-mode-map (kbd "<insert> c c") 'attila/run-python)
(define-key python-mode-map (kbd "<insert> c m") 'run-python)
(define-key python-mode-map (kbd "<insert> e b") 'python-shell-send-buffer)
(define-key python-mode-map (kbd "<insert> e f") 'python-shell-send-defun)
(define-key python-mode-map (kbd "<insert> e r") 'python-shell-send-region)
(add-hook 'elpy-mode-hook (lambda ()
														(color-identifiers-mode t)))
#+end_src

#+RESULTS:
| lambda | nil | (color-identifiers-mode t) |

**** Elpy
#+begin_src emacs-lisp :tangle yes

	(use-package elpy
		:straight t
		:config
		;; Enable elpy in all python buffers
		(elpy-enable)
		(setq python-shell-interpreter "python3")
		:bind
		(:map python-mode-map
					("<insert> d d" . elpy-doc)
					("<insert> t t" . elpy-test)
					("<insert> j r r" . elpy-refactor)
					("<insert> j f f" . elpy-yapf-fix-code)
					("<insert> j f c" . elpy-check)
					("<insert> c o" . elpy-shell-switch-to-buffer)
					))

#+end_src

#+RESULTS:
: elpy-shell-switch-to-buffer

**** jedi-company autocompletion

Elpy company based completion system does not use company-quickhelp. So I use different packages.

#+begin_src emacs-lisp :tangle yes

	(use-package company-jedi
		:ensure t
		:init
		(add-hook 'python-mode-hook (lambda () (add-to-list 'company-backends 'company-jedi)))
		(setq company-jedi-python-bin "python"))

#+end_src

#+RESULTS:
: t

**** Python virtual environment

#+begin_src emacs-lisp :tangle yes

	(use-package pyvenv
		:straight t
		:bind
		(:map python-mode-map
					("<insert> j e w" . pyvenv-workon)
					("<insert> j e a" . pyvenv-activate)
					("<insert> j e d" . pyvenv-deactivate)
					("<insert> j e c" . pyvenv-create)
					("<insert> c r" . pyvenv-restart-python)))

#+end_src

#+RESULTS:
: pyvenv-restart-python

**** Choose python interpreters

#+begin_src emacs-lisp :tangle no

(setq python-shell-interpreter "/docker:base-container:/usr/bin/python3")
(setq python-shell-interpreter "/ssh:root@172.17.0.3:/usr/bin/python3")
(setq tramp-histfile-override "/dev/null")

(file-directory-p "/docker:base-container:/usr/bin/python3")

#+end_src

**** Jinja2 templating

#+begin_src emacs-lisp :tangle yes
(use-package jinja2-mode
	:straight t
	:config
	(add-hook 'jinja2-mode-hook
						(lambda ()
							(electric-indent-mode nil))))
#+end_src

#+RESULTS:

*** Nix
**** Nix mode

#+begin_src emacs-lisp :tangle yes :results none

	(use-package nix-mode
		:straight t
		:mode
		("\\.nix\\'"))

	(use-package company-nixos-options
		:straight t
		:demand t
		:config
		(add-hook 'nix-mode-hook
								(lambda ()
									(setq-local company-backends
															(append '((company-nixos-options
																				 :separate
																				 company-dabbrev)))))))

#+end_src

**** Helm nixos options

#+begin_src emacs-lisp :tangle yes

	(use-package helm-nixos-options
		:straight t
		:bind
		("<insert> h n" . helm-nixos-options))

#+end_src

#+RESULTS:
: helm-nixos-options
**** Nix buffer

#+begin_src emacs-lisp :tangle yes
(use-package nix-buffer
	:straight t
	:config
	(setq nix-buffer-root-file "shell.nix"))
#+end_src

#+RESULTS:
: t

*** Ansible
**** Syntax highlight
#+begin_src emacs-lisp :tangle yes

	(use-package ansible
		:straight t
		:defer t
		:init
		(add-hook
		 'yaml-mode-hook
		 (lambda ()
			 (with-current-buffer (current-buffer)
				 (save-excursion
					 (goto-char (point-min))
					 (when (search-forward "tasks:" nil t)
						 (ansible t)
						 nil))))))

#+end_src
**** Code completion

#+begin_src emacs-lisp :tangle yes

	(use-package company-ansible
		:straight t
		:defer t
		:init
		(add-hook 'ansible-hook
							(lambda ()
								(setq-local company-backends
														(append '((company-ansible)))))))

#+end_src

#+RESULTS:

*** MongoDB
**** Babel with MongoDB
#+begin_src emacs-lisp :tangle yes

	(use-package ob-mongo
		:straight t
		:config
		(org-babel-do-load-languages
			 'org-babel-load-languages
			 '((mongo . t)
				 (shell . t)
         (js . t)
				 (python . t))))

#+end_src

#+RESULTS:
: t

**** mongo REPL

#+begin_src emacs-lisp :tangle yes

	(use-package inf-mongo
		:straight t
		:config
		(setq inf-mongo-command "mongo 127.0.0.1:27017")
		:bind
		("<insert> 2 d m" . inf-mongo))

#+end_src

#+RESULTS:
: inf-mongo

**** Async org babel code evaluation

#+begin_src emacs-lisp :tangle yes
	(use-package ob-async
		:straight t
		:demand t)
#+end_src
*** ini files

#+begin_src emacs-lisp :tangle yes
(use-package ini-mode
	:straight t
	:mode ("\\.ini\\'"))
#+end_src

#+RESULTS:
: ((\.ini\' . ini-mode) (\.?zshrc . shell-script-mode) (\.?bashrc . shell-script-mode) (\(?:\(?:\(?:\.\(?:b\(?:\(?:abel\|ower\)rc\)\|json\(?:ld\)?\)\|composer\.lock\)\)\'\) . json-mode) (\.js\' . js2-mode) (\.liq\' . web-mode) (\.svg\' . web-mode) (\.css\' . web-mode) (\.html\' . web-mode) (\.djhtml\' . web-mode) (\.mustache\' . web-mode) (\.erb\' . web-mode) (\.as[cp]x\' . web-mode) (\.[agj]sp\' . web-mode) (\.tpl\.php\' . web-mode) (\.phtml\' . web-mode) (\.log\' . logview) (\.bats\' . bats-mode) (\.hva\' . latex-mode) (\.drv\' . latex-mode) (\.[Cc][Ss][Vv]\' . csv-mode) (Dockerfile\' . dockerfile-mode) (/\.editorconfig\' . editorconfig-conf-mode) (\.elm\' . elm-mode) (/fish_funced\..*\' . fish-mode) (\.fish\' . fish-mode) (/etc/gitconfig\' . gitconfig-mode) (/\.gitmodules\' . gitconfig-mode) (/git/config\' . gitconfig-mode) (/modules/.*/config\' . gitconfig-mode) (/\.git/config\' . gitconfig-mode) (/\.gitconfig\' . gitconfig-mode) (\.glsl\' . glsl-mode) (\.geom\' . glsl-mode) (\.frag\' . glsl-mode) (\.vert\' . glsl-mode) (\.graphql\' . graphql-mode) (\.hsc\' . haskell-mode) (\.l[gh]s\' . literate-haskell-mode) (\.[gh]s\' . haskell-mode) (\.cabal\' . haskell-cabal-mode) (\.chs\' . haskell-c2hs-mode) (\.ghci\' . ghci-script-mode) (\.dump-simpl\' . ghc-core-mode) (\.hcr\' . ghc-core-mode) (\(?:build\|profile\)\.boot\' . clojure-mode) (\.cljs\' . clojurescript-mode) (\.cljc\' . clojurec-mode) (\.\(clj\|dtm\|edn\)\' . clojure-mode) (\.pug\' . jade-mode) (\.jade\' . jade-mode) (\.less\' . less-css-mode) (\.log\' . log4j-mode) (/git-rebase-todo\' . git-rebase-mode) (/nginx/.+\.conf\' . nginx-mode) (nginx\.conf\' . nginx-mode) (\.nix.in\' . nix-mode) (\.nix\' . nix-mode) (\.R$ . R-mode) (\.jl\' . julia-mode) (\.tlc$ . tlc-mode) (\.m$ . matlab-mode) (\.\(plantuml\|pum\|plu\)\' . plantuml-mode) (\.strace\' . strace-mode) (\.styl\' . stylus-mode) (\.ts$ . typescript-mode) (\.\(e?ya?\|ra\)ml\' . yaml-mode) (\.gpg\(~\|\.~[0-9]+~\)?\' nil epa-file) (\.elc\' . elisp-byte-code-mode) (\.dz\' nil jka-compr) (\.xz\' nil jka-compr) (\.lzma\' nil jka-compr) (\.lz\' nil jka-compr) (\.g?z\' nil jka-compr) (\.bz2\' nil jka-compr) (\.Z\' nil jka-compr) (\.vr[hi]?\' . vera-mode) (\(?:\.\(?:rbw?\|ru\|rake\|thor\|jbuilder\|rabl\|gemspec\|podspec\)\|/\(?:Gem\|Rake\|Cap\|Thor\|Puppet\|Berks\|Vagrant\|Guard\|Pod\)file\)\' . ruby-mode) (\.re?st\' . rst-mode) (\.pyw?\' . python-mode) (\.scss\' . scss-mode) (\.awk\' . awk-mode) (\.\(u?lpc\|pike\|pmod\(\.in\)?\)\' . pike-mode) (\.idl\' . idl-mode) (\.java\' . java-mode) (\.m\' . objc-mode) (\.ii\' . c++-mode) (\.i\' . c-mode) (\.lex\' . c-mode) (\.y\(acc\)?\' . c-mode) (\.[ch]\' . c-mode) (\.\(CC?\|HH?\)\' . c++-mode) (\.[ch]\(pp\|xx\|\+\+\)\' . c++-mode) (\.\(cc\|hh\)\' . c++-mode) (\.\(bat\|cmd\)\' . bat-mode) (\.[sx]?html?\(\.[a-zA-Z_]+\)?\' . html-mode) (\.svgz?\' . image-mode) (\.svgz?\' . xml-mode) (\.x[bp]m\' . image-mode) (\.x[bp]m\' . c-mode) (\.p[bpgn]m\' . image-mode) (\.tiff?\' . image-mode) (\.gif\' . image-mode) (\.png\' . image-mode) (\.jpe?g\' . image-mode) (\.te?xt\' . text-mode) (\.[tT]e[xX]\' . tex-mode) (\.ins\' . tex-mode) (\.ltx\' . latex-mode) (\.dtx\' . doctex-mode) (\.org\' . org-mode) (\.el\' . emacs-lisp-mode) (Project\.ede\' . emacs-lisp-mode) (\.\(scm\|stk\|ss\|sch\)\' . scheme-mode) (\.l\' . lisp-mode) (\.li?sp\' . lisp-mode) (\.[fF]\' . fortran-mode) (\.for\' . fortran-mode) (\.p\' . pascal-mode) (\.pas\' . pascal-mode) (\.\(dpr\|DPR\)\' . delphi-mode) (\.ad[abs]\' . ada-mode) (\.ad[bs].dg\' . ada-mode) (\.\([pP]\([Llm]\|erl\|od\)\|al\)\' . perl-mode) (Imakefile\' . makefile-imake-mode) (Makeppfile\(?:\.mk\)?\' . makefile-makepp-mode) (\.makepp\' . makefile-makepp-mode) (\.mk\' . makefile-gmake-mode) (\.make\' . makefile-gmake-mode) ([Mm]akefile\' . makefile-gmake-mode) (\.am\' . makefile-automake-mode) (\.texinfo\' . texinfo-mode) (\.te?xi\' . texinfo-mode) (\.[sS]\' . asm-mode) (\.asm\' . asm-mode) (\.css\' . css-mode) (\.mixal\' . mixal-mode) (\.gcov\' . compilation-mode) (/\.[a-z0-9-]*gdbinit . gdb-script-mode) (-gdb\.gdb . gdb-script-mode) ([cC]hange\.?[lL]og?\' . change-log-mode) ([cC]hange[lL]og[-.][0-9]+\' . change-log-mode) (\$CHANGE_LOG\$\.TXT . change-log-mode) (\.scm\.[0-9]*\' . scheme-mode) (\.[ckz]?sh\'\|\.shar\'\|/\.z?profile\' . sh-mode) (\.bash\' . sh-mode) (\(/\|\`\)\.\(bash_\(profile\|history\|log\(in\|out\)\)\|z?log\(in\|out\)\)\' . sh-mode) (\(/\|\`\)\.\(shrc\|[kz]shrc\|bashrc\|t?cshrc\|esrc\)\' . sh-mode) (\(/\|\`\)\.\([kz]shenv\|xinitrc\|startxrc\|xsession\)\' . sh-mode) (\.m?spec\' . sh-mode) (\.m[mes]\' . nroff-mode) (\.man\' . nroff-mode) (\.sty\' . latex-mode) (\.cl[so]\' . latex-mode) (\.bbl\' . latex-mode) (\.bib\' . bibtex-mode) (\.bst\' . bibtex-style-mode) (\.sql\' . sql-mode) (\.m[4c]\' . m4-mode) (\.mf\' . metafont-mode) (\.mp\' . metapost-mode) (\.vhdl?\' . vhdl-mode) (\.article\' . text-mode) (\.letter\' . text-mode) (\.i?tcl\' . tcl-mode) (\.exp\' . tcl-mode) (\.itk\' . tcl-mode) (\.icn\' . icon-mode) (\.sim\' . simula-mode) (\.mss\' . scribe-mode) (\.f9[05]\' . f90-mode) (\.f0[38]\' . f90-mode) (\.indent\.pro\' . fundamental-mode) (\.\(pro\|PRO\)\' . idlwave-mode) (\.srt\' . srecode-template-mode) (\.prolog\' . prolog-mode) (\.tar\' . tar-mode) (\.\(arc\|zip\|lzh\|lha\|zoo\|[jew]ar\|xpi\|rar\|7z\|ARC\|ZIP\|LZH\|LHA\|ZOO\|[JEW]AR\|XPI\|RAR\|7Z\)\' . archive-mode) (\.oxt\' . archive-mode) (\.\(deb\|[oi]pk\)\' . archive-mode) (\`/tmp/Re . text-mode) (/Message[0-9]*\' . text-mode) (\`/tmp/fol/ . text-mode) (\.oak\' . scheme-mode) (\.sgml?\' . sgml-mode) (\.x[ms]l\' . xml-mode) (\.dbk\' . xml-mode) (\.dtd\' . sgml-mode) (\.ds\(ss\)?l\' . dsssl-mode) (\.jsm?\' . javascript-mode) (\.json\' . javascript-mode) (\.[ds]?vh?\' . verilog-mode) (\.by\' . bovine-grammar-mode) (\.wy\' . wisent-grammar-mode) ([:/\]\..*\(emacs\|gnus\|viper\)\' . emacs-lisp-mode) (\`\..*emacs\' . emacs-lisp-mode) ([:/]_emacs\' . emacs-lisp-mode) (/crontab\.X*[0-9]+\' . shell-script-mode) (\.ml\' . lisp-mode) (\.ld[si]?\' . ld-script-mode) (ld\.?script\' . ld-script-mode) (\.xs\' . c-mode) (\.x[abdsru]?[cnw]?\' . ld-script-mode) (\.zone\' . dns-mode) (\.soa\' . dns-mode) (\.asd\' . lisp-mode) (\.\(asn\|mib\|smi\)\' . snmp-mode) (\.\(as\|mi\|sm\)2\' . snmpv2-mode) (\.\(diffs?\|patch\|rej\)\' . diff-mode) (\.\(dif\|pat\)\' . diff-mode) (\.[eE]?[pP][sS]\' . ps-mode) (\.\(?:PDF\|DVI\|OD[FGPST]\|DOCX?\|XLSX?\|PPTX?\|pdf\|djvu\|dvi\|od[fgpst]\|docx?\|xlsx?\|pptx?\)\' . doc-view-mode-maybe) (configure\.\(ac\|in\)\' . autoconf-mode) (\.s\(v\|iv\|ieve\)\' . sieve-mode) (BROWSE\' . ebrowse-tree-mode) (\.ebrowse\' . ebrowse-tree-mode) (#\*mail\* . mail-mode) (\.g\' . antlr-mode) (\.mod\' . m2-mode) (\.ses\' . ses-mode) (\.docbook\' . sgml-mode) (\.com\' . dcl-mode) (/config\.\(?:bat\|log\)\' . fundamental-mode) (\.\(?:[iI][nN][iI]\|[lL][sS][tT]\|[rR][eE][gG]\|[sS][yY][sS]\)\' . conf-mode) (\.\(?:desktop\|la\)\' . conf-unix-mode) (\.ppd\' . conf-ppd-mode) (java.+\.conf\' . conf-javaprop-mode) (\.properties\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-javaprop-mode) (\`/etc/\(?:DIR_COLORS\|ethers\|.?fstab\|.*hosts\|lesskey\|login\.?de\(?:fs\|vperm\)\|magic\|mtab\|pam\.d/.*\|permissions\(?:\.d/.+\)?\|protocols\|rpc\|services\)\' . conf-space-mode) (\`/etc/\(?:acpid?/.+\|aliases\(?:\.d/.+\)?\|default/.+\|group-?\|hosts\..+\|inittab\|ksysguarddrc\|opera6rc\|passwd-?\|shadow-?\|sysconfig/.+\)\' . conf-mode) ([cC]hange[lL]og[-.][-0-9a-z]+\' . change-log-mode) (/\.?\(?:gitconfig\|gnokiirc\|hgrc\|kde.*rc\|mime\.types\|wgetrc\)\' . conf-mode) (/\.\(?:enigma\|gltron\|gtk\|hxplayer\|net\|neverball\|qt/.+\|realplayer\|scummvm\|sversion\|sylpheed/.+\|xmp\)rc\' . conf-mode) (/\.\(?:gdbtkinit\|grip\|orbital/.+txt\|rhosts\|tuxracer/options\)\' . conf-mode) (/\.?X\(?:default\|resource\|re\)s\> . conf-xdefaults-mode) (/X11.+app-defaults/\|\.ad\' . conf-xdefaults-mode) (/X11.+locale/.+/Compose\' . conf-colon-mode) (/X11.+locale/compose\.dir\' . conf-javaprop-mode) (\.~?[0-9]+\.[0-9][-.0-9]*~?\' nil t) (\.\(?:orig\|in\|[bB][aA][kK]\)\' nil t) ([/.]c\(?:on\)?f\(?:i?g\)?\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-mode-maybe) (\.[1-9]\' . nroff-mode) (\.tgz\' . tar-mode) (\.tbz2?\' . tar-mode) (\.txz\' . tar-mode) (\.markdown\' . markdown-mode) (\.md\' . markdown-mode) (\.log\(?:\.[0-9]+\)?\' . logview-mode))

*** yaml mode

#+begin_src emacs-lisp :tangle yes
(use-package yaml-mode
	:straight t
	:mode
	("\\.yaml\\'" "\\.yml\\'" ))
#+end_src
* Tests
* Post Configuration
#+begin_src emacs-lisp :tangle yes

	(when (file-readable-p custom-file)
		(load custom-file))

#+end_src
* Planning
** Milestones
- [ ] Make my line functions prefixable
- [X] Make my rename file or buffer function notice if the buffer is not associated to a file
- [ ] Add company and helm NixOS options
- [ ] Think out new org capture tamplates
- [-] More hydras
	- [X] flyspell
	- [ ] EMMS
- [ ] make flyspell save misspelled words.
	- [ ] Write a Editor independent CLI app.
    - [ ] Setup PostgreSQL
		- [ ] Write CLI client in C
		- [ ] Write Emacs extansion
		- [ ] Write server side code in GO or JAVA or Kotlin
			- [ ] Keep table shorted by number of misspelling
			- [ ] Multi user
			- [ ] Federalization
		- [ ] Create a Web GUI
			- [ ] TTS word to user and wait written input on mistake show right answer and common errors
			- [ ] Browse for common errors

** Decide
*** Build pdf tools and install org-noter
- [ ] Write nix expression for PDF tools
- [ ] Install org noter
*** Write abbrevations
*** Hippie expand?
*** helm-mini or helm-buffer-list
*** expand-region
Expand/shrink selection by semantic regions
*** Parinfer mode or Lispy

foo

#  LocalWords:  Lispy toc Chua's Xmodmap src
#  LocalWords:  avy GC bidi undefine el elc async Clojure JS ov sexp
#  LocalWords:  alists eldoc dir tmp editorconfig Yasnippet Yas dired
#  LocalWords:  searx Edebug js setq flyspell LocalWords Parinfer
