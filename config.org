#+TITLE: Attila Molnar's Emacs config
#+OPTIONS: toc:4 h:4
#+STARTUP overview 

* Introduction
** Rationale
I plan to rewrite my Emacs configuration using literate programing. Thankfully there are brilliant examples out there, like [[http://pages.sachachua.com/.emacs.d/Sacha.html#babel-init][Sacha Chua's Emacs Configuration]], which has a nice explanation 
** Other examples
** Guide lines
* User info

#+NAME: user-info
| variable           | value                 |
|--------------------+-----------------------|
| user-full-name     | Attila Molnar         |
| user-email-address | ate.molnar2@gmail.com |
| user-backup-dir    | ~/.emacs.d/backup/    |

#+begin_src emacs-lisp :tangle yes :var data=user-info
	(message (car (car data)))
#+end_src

#+RESULTS:
: user-full-name

#+begin_src emacs-lisp :tangle yes  
  (defvar user-backup-dir "~/.emacs.d/backup/")
#+end_src

#+RESULTS:
: user-backup-dir

* Hotkeys
** Elisp
#+NAME: elisp-mode-hotkeys
| Keybinding | function | Description |
|------------+----------+-------------|
|            |          |             |
|            |          |             |
|            |          |             |
|            |          |             |

** Org mode

#+NAME: org-mode-hotkeys
| Keybinding   | function                                |
|--------------+-----------------------------------------|
| <insert> t c | org-table-create-or-convert-from-region |
| <insert> t k | org-table-delete-column                 |
|              |                                         |
|--------------+-----------------------------------------|
|              |                                         |

* preconfig
** Elisp
*** Require common lisp

#+begin_src emacs-lisp :tangle yes  
    (require 'cl)
#+end_src

*** binding and recursion limits
Set the maximum numbers of variable bindings, recursive call limit, garbage collector threshold and set CWD to "~/.emacs.d".

#+begin_src emacs-lisp :tangle yes 
  (setq max-specpdl-size 10000)
  (setq max-lisp-eval-depth 10000)
#+end_src

*** Garbage collection byte threshold
		 
Emacs has a blocking garbage collector, and its collection threshold is very low by default (8KB), so much of time is spent by the GC. On a modern machine this can be mitigated by increasing the gc threshold limit to 20MB, as recommended by the [[https://github.com/lewang/flx][flx package documentation]]

#+begin_src emacs-lisp :tangle yes  
  (setq gc-cons-threshold 20000000)
#+end_src

*** Default directory

#+begin_src emacs-lisp :tangle yes  
  (setq default-directory "~/.emacs.d")
#+end_src

*** Print trace on error

#+begin_src emacs-lisp :tangle yes  

  (toggle-debug-on-error)

#+end_src

** Localization

Ensure global UTF-8 usage, enable hyper and super key on windows. 

#+begin_src emacs-lisp :tangle yes  

	(set-language-environment "UTF-8")
	(set-default-coding-systems 'utf-8)
	(when (eq system-type "windows-nt")
		(setq w32-apps-modifier 'hyper)
		(setq w32-lwindow-modifier 'super)
		(setq w32-rwindow-modifier 'hyper))

#+end_src

#+RESULTS:

** Prefer newest .elc files

If a file suffix is not exaclty specified do not stop on the first hit, but search for the newest on

#+begin_src emacs-lisp :tangle yes  
(setq load-prefer-newer t)
#+end_src

** optimalizations
*** Dsable bidi reordering
bidi display reordering makes Emacs significantly slower, especially when [[http://emacs.stackexchange.com/questions/598/how-do-i-prevent-extremely-long-lines-making-emacs-slow][displaying long lines]].

#+begin_src emacs-lisp :tangle yes  
  (setq bidi-display-reordering nil)
#+end_src

*** Disable auto vertical scrolling
Disable auto vertical scroll adjustion for tall lines

#+begin_src emacs-lisp :tangle yes  
  (setq auto-window-vscroll nil)
#+end_src

** undefine keys

#+begin_src emacs-lisp :tangle yes  

	(global-unset-key (kbd "<insert>"))
	(global-unset-key (kbd "<left>"))
	(global-unset-key (kbd "<right>"))
	(global-unset-key (kbd "<up>"))
	(global-unset-key (kbd "<down>"))
	(global-unset-key (kbd "C-n"))
	(global-unset-key (kbd "C-p"))
	(global-unset-key (kbd "M-l"))
	(global-unset-key (kbd "M-j"))
	(global-unset-key (kbd "C-j"))
	(global-unset-key (kbd "C-l"))
	(global-unset-key (kbd "C-k"))
	(global-unset-key (kbd "C-i"))
	(global-unset-key (kbd "H-m"))
	(global-unset-key (kbd "M-m"))
	(global-unset-key (kbd "C-x c"))
	(global-unset-key (kbd "C-e"))
	(global-unset-key (kbd "M-e"))

	(global-set-key (kbd "<tab>") 'indent-for-tab-command)

#+end_src

#+RESULTS:

* Configuration
:PROPERTIES:
:CUSTOM_ID: babel-init
:END:      
	<<babel-init>>

** Bootstrap straight.el and use-package

#+begin_src emacs-lisp :tangle yes 
  (let ((bootstrap-file
         (concat user-emacs-directory "straight/repos/straight.el/bootstrap.el"))
        (bootstrap-version 3))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
#+end_src

#+RESULTS:
: t

** libraries
*** Third-party libraries

loop: convinient loop library
async: modern async library
dash: modern clojure like list library
diminish: hide or abbreviate minor modes in the mode line
deffered: provide the same functionality as JS promises.
el-mock: mocking library
m-buffer: buffer manipulation library
ov: overlay library
future: use future objects for subprocesses
request: convinient HTTP request library

#+begin_src emacs-lisp :tangle yes
  (use-package dash          :defer  :straight t)
  (use-package s             :defer  :straight t)
  (use-package f             :defer  :straight t)
  (use-package loop          :defer  :straight t)
  (use-package async         :defer  :straight t)
  (use-package deferred      :defer  :straight t)
  (use-package diminish      :demand :straight t) 
  (use-package el-mock       :defer  :straight t)
  (use-package ghub          :defer  :straight t)
  (use-package ghub+         :defer  :straight t)
  (use-package m-buffer      :defer  :straight t)
  (use-package ov            :defer  :straight t)
  (use-package pfuture       :defer  :straight t)
  (use-package request       :defer  :straight t)
#+end_src

#+RESULTS:

** Helper functions
*** Elisp
**** Add function to multiple hooks

 #+begin_src emacs-lisp :tangle yes
 
   (defun attila/add-hooks (hooks mode)
     "Add one mode to multiple hooks"
     (dolist (hook hooks)
       (add-hook hook mode)))

 #+end_src

 #+RESULTS:
 : attila/add-hooks

**** Get first value from list which evaluates true by predicate

 #+begin_src emacs-lisp :tangle yes  

   (defun attila/get-first-true (list filter)
     "Get first value from list which evaluates true by predicate"
     (when list
       (if (funcall filter (car list))
           (car list)
         (attila/get-first-true (cdr list) filter))))

 #+end_src

**** association lists
***** Merge alists

Borrowed from marshal.el

#+begin_src emacs-lisp :tangle yes 

	(defun attila/alist-merge (alist1 alist2 &optional append)
		(let ((res alist1))
			(if alist2
					(let* ((pair (car alist2))
								 (x (car pair))
								 (y (cdr pair)))
						(marshal--alist-merge
						 (marshal--alist-add alist1 x y append)
						 (cdr alist2)))
				alist1)))

#+end_src

#+RESULTS:
: attila/alist-merge

*** UX
**** Smart line beginnig
#+begin_src emacs-lisp :tangle yes  
  (defun attila-smart-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+end_src

**** Smart rename

Rename buffer or file and buffer if it is already saved.

#+begin_src emacs-lisp :tangle yes

	(defun attila/smart-rename-buffer-file (new-name)
		"Renames both current buffer and file (if saved) it's visiting to NEW-NAME."
		(interactive (list (read-string "New Name: " (buffer-name))))
		(let ((name (buffer-name))
					(filename (buffer-file-name)))
			(if (get-buffer new-name)
					(message "A buffer named '%s' already exists!" new-name)
				(progn
					(when (file-exists-p filename)
						(rename-file filename new-name 1))
					(rename-buffer new-name)
					(set-visited-file-name new-name)
					(set-buffer-modified-p nil)))))

#+end_src

#+RESULTS:
: attila/smart-rename-buffer-file

**** Cut lines

#+begin_src emacs-lisp :tangle yes

	(defun attila/line-cut (prefix-arg)
		"Cut active line"
		(interactive (list current-prefix-arg))
		(let ((line-num (if prefix-arg prefix-arg 1))
					(counter 0))
			(while (< counter line-num)
				(setq counter (+ 1 counter))
				(kill-region (line-beginning-position) (line-end-position))
				(delete-forward-char 1 nil))))


	(global-set-key (kbd "<insert> l d") 'attila/line-cut)


	(defun my/test (prefix-arg)
		(interactive (list current-prefix-arg))
		(message prefix-arg))


	;;;
	;;;
	;;
	;;

#+end_src
**** Multiply line above/below

#+begin_src emacs-lisp :tangle yes

		(defun attila/line-duplicate-below ()
			"Duplicate active line"
			(interactive)
			;; insertion = newline + active line
			(let ((insertion (concat "\n" (buffer-substring (line-beginning-position) (line-end-position)))))
				(end-of-line)
				(insert insertion)
				;; Indent (tab) command in certain modes with automatic indention will lead to right identation
				;; Doing it at the end of the line will not cause any harm in others modes, expect in the ones
				;; where multiple identation levels carry differen meanings (python, yaml etc...)
				;; which is still a TODO task;
				(end-of-line)
				(indent-for-tab-command)))

		(defun attila/line-duplicate-above ()
			"Duplicate active line above"
			(interactive)
			;; insertion = newline + active line
			(let ((insertion (concat (buffer-substring (line-beginning-position) (line-end-position)))))
				(beginning-of-line)
				(insert "\n")
				(forward-line -1)
				(insert insertion)
				;; Indent (tab) command in certain modes with automatic indention will lead to right identation
				;; Doing it at the end of the line will not cause any harm in others modes, expect in the ones
				;; where multiple identation levels carry differen meanings (python, yaml etc...)
				;; which is still a TODO task;
				(end-of-line)
				(indent-for-tab-command)))

#+end_src
** Appearance
*** Layout

#+begin_src emacs-lisp :tangle yes
(tool-bar-mode -1)
(menu-bar-mode -1)
(scroll-bar-mode -1)
#+end_src

*** Theme and font
#+begin_src emacs-lisp :tangle yes
  (use-package monokai-theme
    :demand t
    :straight t)

(when (window-system)
		(set-default-font "Fira Code"))
#+end_src

#+RESULTS:
		
*** Parenthesis

Highlight parentheses at point and its pair. Use rainbow colors for the different nesting levels of parenthesis.

#+begin_src emacs-lisp :tangle yes 
(show-paren-mode 1)

(use-package rainbow-delimiters
  :straight t
	:config
	;; Enable it in all programing modes
	(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
	;; Set colors to travel through the VIS spectrum from red to blue
	'(rainbow-delimiters-depth-1-face ((t (:foreground "light slate blue"))))
	'(rainbow-delimiters-depth-2-face ((t (:foreground "cyan"))))
	'(rainbow-delimiters-depth-3-face ((t (:foreground "lime green"))))
	'(rainbow-delimiters-depth-4-face ((t (:foreground "yellow green"))))
	'(rainbow-delimiters-depth-5-face ((t (:foreground "yellow"))))
	'(rainbow-delimiters-depth-6-face ((t (:foreground "goldenrod"))))
	'(rainbow-delimiters-depth-7-face ((t (:foreground "dark orange"))))
	'(rainbow-delimiters-depth-8-face ((t (:foreground "orange red"))))
	'(rainbow-delimiters-depth-9-face ((t (:foreground "red2")))))
#+end_src

*** Colorize strings, which represent colors

#+begin_src emacs-lisp :tangle yes  
  (use-package rainbow-mode
    :demand t
    :straight t
    :config
    (attila/add-hooks
     '(stylus-mode-hook
       less-css-mode-hook
       css-mode-hook)
     (lambda () (rainbow-mode))))
#+end_src

#+RESULTS:
: t

*** Colorize compilation buffer

#+begin_src emacs-lisp :tangle yes 
(require 'ansi-color)

(defun colorize-compilation-buffer ()
	(toggle-read-only)
	(ansi-color-apply-on-region compilation-filter-start (point))
	(toggle-read-only))

(add-hook 'compilation-filter-hook 'colorize-compilation-buffer)
#+end_src

*** Highlight point on window scroll

#+begin_src emacs-lisp :tangle yes  

  (use-package beacon
    :straight t
    :demand t
    :config
    (beacon-mode 1)
    (setq beacon-blink-duration 0.05)
    (setq beacon-color "#a6e22e")
    (setq beacon-blink-when-window-scrolls nil))

#+end_src

#+RESULTS:
: t

*** Highlight  page intersection on scrolling

#+begin_src emacs-lisp :tangle yes  

  (use-package highlight-context-line
    :straight t
    :config
    (highlight-context-line-mode))

#+end_src

*** Smooth scrolling

#+begin_src emacs-lisp :tangle yes

	(use-package sublimity
		:straight t
		:config
		(require 'sublimity-scroll)
		(sublimity-mode 1))

#+end_src
*** Visual line wrapping 

#+begin_src emacs-lisp :tangle yes  

  (attila/add-hooks
   '(Man-mode-hook
     org-mode-hook
     markdown-mode-hook)
   (lambda ()
     (visual-line-mode)))  

#+end_src

#+RESULTS:

*** Indentation adaptive visal line wraping

#+begin_src emacs-lisp :tangle yes  

	(use-package adaptive-wrap
		:straight t
		:diminish adaptive-wrap-prefix-mode
		:defer t
		:init
		(attila/add-hooks
		 '(prog-mode-hook
			 text-mode-hook)
		 'my-adaptive-wrap-autoload)
		:commands
		my-adaptive-wrap-autoload
		:config
		(defun my-adaptive-wrap-autoload ()
			(adaptive-wrap-prefix-mode t)))

#+end_src

#+RESULTS:
: t

** Behavior
*** Store costumization in a separate file

Much better than tainting the =init.el= file.

#+begin_src emacs-lisp :tangle yes

	(setq custom-file "~/.emacs.d/custom-options.el")

#+end_src

#+RESULTS:
: ~/.emacs.d/custom-options.el

*** Universal argument

#+begin_src emacs-lisp :tangle yes

	(define-key global-map (kbd "H-n") 'universal-argument)
	(define-key universal-argument-map (kbd "C-u") nil)
	(define-key universal-argument-map (kbd "H-n") 'universal-argument-more)
	(define-key global-map (kbd "C-u") 'kill-whole-line)
	(eval-after-load 'evil-maps
		'(progn
			 (define-key evil-motion-state-map (kbd "H-n") nil)
			 (define-key evil-motion-state-map (kbd "C-u") 'evil-scroll-up)))

#+end_src
*** Helm
**** Helm core
#+begin_src emacs-lisp :tangle yes  

	(use-package helm
		:straight t
		:diminish helm-mode
		:config
		(require 'helm-config)
		(require 'helm-sys)
		(setq enable-recursive-minibuffers t)
		;; make helm adapt to my choices
		(helm-adaptive-mode)
		;; Make helm use the active window for interaction
		(setq
		 ;; Open helm buffer in current winsow
		 helm-split-window-in-side-p           t
		 ;; cylcle throught helm results
		 helm-move-to-line-cycle-in-source     t
		 ;; search for library in `require' and `declare-function' sexp.
		 helm-ff-search-library-in-sexp        t
																					; scroll 8 lines other window using M-<next>/M-<prior>
		 helm-scroll-amount                    8
		 ;; simultanusly displayed candiate limit
		 helm-candidate-number-limit 100
		 ;; delay to update candidate list 
		 helm-input-idle-delay 0.1
		 ;; Use the recent file, when finding files
		 helm-ff-file-name-history-use-recentf t)
		(helm-mode 1)

		;; Use helm for file finding
		(global-unset-key (kbd "C-x C-f"))
		;; make sure C-h is no longer a prefix key inside a helm buffer
		(define-key helm-map (kbd "C-h") nil)
		:bind
		(
		 ("<insert> x f" . helm-find-files)
		 ("<insert> x d" . dired)
		 ("<insert> b b" . switch-to-buffer)
		 ;; Use helm for command prompt
		 ("M-x" . helm-M-x)
		 ("<insert> <insert>" . helm-M-x)
		 ;; Use helm-buffers-list instead of default helm buffer lister
		 ("s-x b" . helm-buffers-list)
		 ;; get the list of the bookmarks (C-x r m for saving bookmarks)
		 ("C-c p j" . helm-bookmarks)
		 ;; More easier way to acces Emacs's internal "clipboard"
		 ("<insert> i h" . helm-show-kill-ring) ;; as clipboard history
		 ;; Use helm with isearch
		 ("<insert> s s" . helm-occur)
		 ;; resume to previous search
		 ("<insert> s r" . helm-resume)
		 ;; Show kill-ring
		 ("<insert> i h" . helm-show-kill-ring)
		 ;; helm-ls-git
		 ("C-<f6>" . helm-browse-project)
		 ;; helm imenu
		 ("<insert> s i" . helm-imenu)
		 ;; helm-c-source-yasnippet
		 ("<insert> e e" . helm-yas-complete)
		 ("<insert> e f" . helm-yas-visit-snippet-file)
		 ("<insert> e r" . helm-yas-create-snippet-on-region)
		 ;; helm top
		 ("<insert> 2 t o" . helm-top)
		 ("C-x c C-t" . helm-tramp )
		 ;; helm locate
		 ("<insert> s l" . helm-locate)
		 ;; show killring
		 ("<insert> q" . helm-show-kill-ring)
		 ;; helm help
		 ("<insert> h w" . helm-man-woman)
		 ("<insert> h i e" . helm-info-elisp)
		 ("<insert> h i m" . helm-info-magit)
		 ("<insert> h i z" . helm-info-zsh)
		 ("<insert> h e a" . helm-apropos)
		 ("<insert> h e f" . describe-function)
		 ("<insert> h e k" . describe-key-briefly)
		 ("<insert> h e m" . describe-mode)
		 ;; ??? 
		 ("<C-kp-4>" . sm/toggle-showcss)
		 ("<insert> i c" . helm-colors))
		:bind
		(:map helm-map
					("<insert> j j" . helm-select-action)
					("<insert> r" . helm-ff-run-find-file-as-root)
					("<insert> d d" . dired-find-file)
					("<insert> d o" . dired-find-file) 
					("C-k" . helm-next-line) 
					("C-i" . helm-previous-line)
					("C-j" . helm-execute-persistent-action)
					)
		(:map helm-find-files-map
					("C-j" . helm-find-files-up-one-level)
					("C-l" . helm-execute-persistent-action))
		(:map helm-top-map
					("<insert> j c" . helm-top-run-sort-by-cpu)
					("<insert> j m" . helm-top-run-sort-by-mem)
					("<insert> j k" . 'helm-top-run-sort-by-com)
					("<insert> j u" . 'helm-top-run-sort-by-user)
					))

#+end_src

#+RESULTS:
: helm-top-run-sort-by-user

**** Helm projectile

#+begin_src emacs-lisp :tangle yes  

  (use-package projectile
    :straight t
    :diminish projectile-mode "pro"
    :config
    (use-package helm-projectile
      :straight t
      :config
      (helm-projectile-on))
    (projectile-global-mode)
    (setq projectile-globally-ignored-directories
          (append '(
                    "out"
                    "target"
                    "venv"
                    "node_modules"
                    ) ))
    (setq projectile-known-projects-file "~/.emacs.d/projectile-bookmarks.eld")
    (setq projectile-enable-caching t)
    (use-package helm-ag :straight t)
    :bind
    ("<insert> p p" . helm-projectile-switch-project)
    ("<insert> p +" . projectile-add-known-project)
    ("<insert> p -" . projectile-remove-known-project)
    ("<insert> p f" . helm-projectile-find-file)
    ("<insert> p b" . helm-projectile-switch-to-buffer)
    ("<insert> p i" . projectile-invalidate-cache)
    ;; Extreamly fast mehotd search in all recent project files.
    ("<insert> p a" . helm-projectile-ag)
    ("<insert> s p" . helm-projectile-ag)
    ("<insert> x p" . projectile-save-project-buffers)
    ;; Very slow, when many project is present.
    ("<insert> p g" . helm-projectile-find-file-in-known-projects)
    ;; Project level replace, what can go wrong?
    ("<insert> p r t" . projectile-replace)
    ("<insert> p r r" . projectile-replace-regexp))

#+end_src

#+RESULTS:
: projectile-replace-regexp

**** helm swoop

*** GUI interaction
**** Basic control

#+begin_src emacs-lisp :tangle yes

  (global-set-key (kbd "<insert> <escape>") 'save-buffers-kill-terminal)
  (global-set-key (kbd "<insert> x x") 'save-buffer)

#+end_src
**** Prevent backgrounding

#+begin_src emacs-lisp :tangle yes

  (when (display-graphic-p)
    (progn
      (global-unset-key (kbd "C-z"))
      (global-unset-key (kbd "C-x C-z"))))  

#+end_src

**** buffer operations

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> b K") 'kill-matching-buffers)
	(global-set-key (kbd "<insert> b r") 'attila/smart-rename-buffer-file)
	(global-set-key (kbd "<insert> r t") 'query-replace)
	(global-set-key (kbd "<insert> b k") 'kill-buffer)
	(global-set-key (kbd "<insert> x a") 'save-some-buffers)
	(global-set-key (kbd "<insert> x o") 'find-file-read-only)
	(global-set-key (kbd "<insert> <escape>") 'save-buffers-kill-terminal)
	(global-set-key (kbd "<insert> x x") 'save-buffer)
	(global-set-key (kbd "<insert> SPC SPC") 'set-mark-command)

#+end_src

#+RESULTS:
: set-mark-command

*** Navigation
**** Switch&rotate windows, switch frames
#+begin_src emacs-lisp :tangle yes  

  (defun rotate-windows (arg)
    "Rotate your windows; use the prefix argument to rotate the other direction"
    (interactive "P")
    (if (not (> (count-windows) 1))
        (message "You can't rotate a single window!")
      (let* ((rotate-times (prefix-numeric-value arg))
             (direction (if (or (< rotate-times 0) (equal arg '(4)))
                            'reverse 'identity)))
        (dotimes (_ (abs rotate-times))
          (dotimes (i (- (count-windows) 1))
            (let* ((w1 (elt (funcall direction (window-list)) i))
                   (w2 (elt (funcall direction (window-list)) (+ i 1)))
                   (b1 (window-buffer w1))
                   (b2 (window-buffer w2))
                   (s1 (window-start w1))
                   (s2 (window-start w2))
                   (p1 (window-point w1))
                   (p2 (window-point w2)))
              (set-window-buffer-start-and-point w1 b2 s2 p2)
              (set-window-buffer-start-and-point w2 b1 s1 p1)))))))

  (global-set-key (kbd "M-o") 'rotate-windows)
  (global-set-key (kbd "H-o") 'other-window)
  (global-set-key (kbd "C-o") 'other-frame)

#+end_src

**** Move chars and lines
		 
#+begin_src emacs-lisp :tangle yes  
  (global-set-key (kbd "H-j") 'backward-char)
  (global-set-key (kbd "H-l") 'forward-char)
  (global-set-key (kbd "H-k") 'next-line)
  (global-set-key (kbd "H-i") 'previous-line)
#+end_src

**** Scroll up/down move subwords

#+begin_src emacs-lisp :tangle  yes

  (global-set-key (kbd "M-i") 'scroll-down-command)
  (global-set-key (kbd "M-k") 'scroll-up-command)
  (global-set-key (kbd "M-l") 'forward-word)
  (global-set-key (kbd "M-j") 'backward-word)

#+end_src

**** subword jumps

#+begin_src emacs-lisp :tangle yes  
  (attila/add-hooks
   '(js-mode-hook
     clojure-mode-hook
     python-mode-hook
     java-mode-hook
     c-mode-hook
     haskell-mode-hook
     jade-mode-hook
     elm-mode-hook
     julia-mode-hook
     stylus-mode-hook)
   'subword-mode)
#+end_src

**** Beginning of line and buffer

#+begin_src emacs-lisp :tangle yes
	(global-set-key (kbd "H-M-j") 'attila-smart-move-beginning-of-line)
	(global-set-key (kbd "H-M-l") 'move-end-of-line)
	(global-set-key (kbd "C-i") 'beginning-of-buffer)
	(global-set-key (kbd "C-k") 'end-of-buffer)
#+end_src

#+RESULTS:
: end-of-buffer

**** Jump to char char-pair or line

I use key-chords to invoke avy functions

#+begin_src emacs-lisp :tangle yes

  (use-package avy
    :straight t
    :config
    (avy-setup-default))

#+end_src

**** Go back and forth changed regions

#+begin_src emacs-lisp :tangle yes

  (use-package goto-chg
    :straight t
    :bind
    (("C-u" . goto-last-change)
     ("C-S-u" . goto-last-change-reverse)))

#+end_src

**** Forward/backward sexp and sentences

#+begin_src emacs-lisp :tangle yes 

	(global-set-key (kbd "H-'") 'forward-sexp)
	(global-set-key (kbd "H-;") 'backward-sexp)
	(global-set-key (kbd "M-'") 'forward-sentence)
	(global-set-key (kbd "M-;") 'backward-sentence)

#+end_src

#+RESULTS:
: backward-sentence

**** Forward/backward sentence

#+begin_src emacs-lisp :tangle yes  

	(global-set-key (kbd "H-M-;") 'backward-sentence)
  (global-set-key (kbd "H-M-'") 'forward-sentence)

#+end_src

#+RESULTS:
: forward-sentence

*** key chords

#+begin_src emacs-lisp :tangle yes  

  (use-package key-chord
    :straight t
    :init 
    (add-hook 'after-init-hook
              (lambda () (key-chord-mode t)))
    :config
    (require 'key-chord)
    (setq key-chord-two-keys-delay 0.08)
    (setq key-chord-one-key-delay 0.08)
    (key-chord-define-global "jf" 'avy-goto-char)
    (key-chord-define-global "jd" 'avy-goto-char-2)
    (key-chord-define-global "jg" 'avy-goto-line)
    (key-chord-define-global "kd" 'kill-word)
    (key-chord-define-global "kf" 'backward-kill-word))

#+end_src

#+RESULTS:
: t

*** Selection

Bindings defined with hydra

#+begin_src emacs-lisp :tangle yes

	(use-package expand-region
	 :straight t)

#+end_src
*** Show function synopsis with eldoc

Allow eldoc to show function synopsis in the echo area in multiple line if needed.

#+begin_src emacs-lisp :tangle yes  

  (use-package eldoc
    :straight t
    :defer t
    :diminish eldoc-mode
    :init
    (attila/add-hooks
     '(emacs-lisp-mode-hook)
     'turn-on-eldoc-mode)
    :config
    (setq eldoc-echo-area-use-multiline-p t))
    

#+end_src

#+RESULTS:
: t

*** Editor server

Run Emacs as a server and connect to it with =emacsclient= from the CLI.

#+begin_src emacs-lisp :tangle yes

  (require 'server)
  (unless (server-running-p)
    (cond
     ((eq system-type 'windows-nt)
      (setq server-auth-dir "~\\.emacs.d\\server\\"))
     ((eq system-type 'gnu/linux)
      (setq server-auth-dir "~/.emacs.d/server/")))
    (setq server-name "emacs-server-file")
    (server-start))

#+end_src

*** Centralized backup and autoclean backup dir

Make emacs to write backup and auto-save files in a [[https://www.emacswiki.org/emacs/BackupDirectory][specific directory]] instead of messing up the project file trees. 

#+begin_src emacs-lisp :tangle yes

  (setq backup-directory-alist
        `((".*" . ,user-backup-dir)))
  (setq auto-save-file-name-transforms
        `((".*" ,user-backup-dir t)))

#+end_src

#+RESULTS:
| .* | /tmp/ | t |

Delete backup files older then a week

#+begin_src emacs-lisp :tangle yes  

  (let ((week (* 60 60 24 7))
        (current (float-time (current-time))))
    (dolist (file (directory-files user-backup-dir t))
      (when (and (backup-file-name-p file)
                 (> (- current (float-time (fifth (file-attributes file))))
                    week))
        (message "%s" file)
        (delete-file file))))

#+end_src

#+RESULTS:

*** Make scripts executable after save

#+begin_src emacs-lisp :tangle yes

  (add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)


#+end_src

*** Respect  .editorconfig gile

#+begin_src emacs-lisp :tangle yes
  (use-package editorconfig
    :straight t
    :diminish editorconfig-mode
    :config
    (editorconfig-mode 1))
#+end_src

** Editing
*** Hydra

#+begin_src emacs-lisp :tangle yes

	(use-package hydra
		:straight t
		:config
		;; hint int the echo area
		(setq hydra-is-helpful t)
		;; Use dedicated hinting window
		(setq hydra-lv t)
		;; Separate hinter and echo area
		(setq lv-use-separator t)
		(defhydra hydra-zoom (global-map "<f2>")
		"zoom"
		("g" text-scale-increase "in")
		("l" text-scale-decrease "out"))

		(defun hydra-edit/pre ()
			(set-cursor-color "#60E896"))

		(defun hydra-edit/post ()
			(set-cursor-color "#FFFFFF"))

		(defun hydra-seek/pre ()
			(set-cursor-color "#E52B50"))

		(defun hydra-seek/post ()
			(set-cursor-color "#FFFFFF"))

		(defhydra hydra-zoom
			(global-map "<insert> ;"
									:color pink
									:pre hydra-edit/pre
									:post hydra-edit/post)
			"hydra-edit"

			("q" nil))

		(defun hydra-seek/pre ()
			(set-cursor-color "#E52B50"))

		(defun hydra-seek/post ()
			(set-cursor-color "#FFFFFF"))

		(defhydra hydra-zoom
			(global-map "<insert> SPC"
									:color pink
									:pre hydra-seek/pre
									:post hydra-seek/post)
			"hydra-seek"
			("w" kill-ring-save "copy" :color blue)
			("SPC" set-mark-command "mark")
			("s s" helm-occur "search")
			("s m m" helm-rifle-current-buffer)
			("s p" helm-projectile-ag "p-search")
			("s l" helm-locate "l-search")
			("s r" helm-resume "ffind")
			("x f" helm-find-files "ffind")
			("f" avy-goto-char "j1")
			("d" avy-goto-char-2 "j2")
			("g" avy-goto-line)
			("p p" helm-projectile-switch-project)
			("p f" helm-projectile-find-file)
			;; scroll
			("i" scroll-down-command)
			("k" scroll-up-command)
			;; Select
			("]" er/expand-region)
			("[" er/contract-region)
			("q" nil)
			;; Editing
			("l k" attila/line-cut)
			("l d" end-of-line)
			("l a" attila-smart-move-beginning-of-line)

			;; git
			("v v" magit-status)))

#+end_src

#+RESULTS:
: t

*** Use spaces instead of tabs

Elpy prefers spaces over tabs so do I. =tab-stop-list= is a fallback when =indent relative= does not find the next tab stop

#+begin_src emacs-lisp :tangle yes

  (setq-default indent-tabs-mode-mode nil)
  (setq-default tab-width 2)
  (setq tab-stop-list (number-sequence tab-width 120 tab-width))
  (defvaralias 'c-basic-offset 'tab-width)
  (defvaralias 'cperl-indent-level 'tab-width)

#+end_src

*** Perl style regex for replace

#+begin_src emacs-lisp :tangle yes

	(use-package visual-regexp
    :straight t
		:config
		(use-package visual-regexp-steroids
			:bind
			("<insert> r r" . vr/replace)))

	;; switch re builder syntax `string` instead of `read`, since it is more convinient
	;; source: https://www.masteringemacs.org/article/re-builder-interactive-regexp-builder
	(setq reb-re-syntax 'string)


#+end_src

#+RESULTS:
: string

*** Undo tree

#+begin_src emacs-lisp :tangle yes  

  (use-package undo-tree
    :straight t
    :diminish undo-tree-mode
    :config
    (global-undo-tree-mode)
    :bind
    (("H-u" . undo-tree-undo)
     ("M-u" . undo-tree-redo)
     ("<insert> u" . undo-tree-visualize)))

#+end_src

*** Multiple cursors

#+begin_src emacs-lisp :tangle yes  
  (use-package multiple-cursors
    :straight t
    :bind
    (( "H-m" . mc/mark-next-like-this)
     ( "M-m" . mc/mark-previous-like-this)
     ( "C-M-m" . mc/mark-all-like-this)))
#+end_src

*** Preserve point position relative to the window.

#+begin_src emacs-lisp :tangle yes
(setq scroll-preserve-screen-position t)
#+end_src

*** Ask for "y" or "n" for saving

#+begin_src emacs-lisp :tangle yes  
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

*** Parenthesevs
**** Kill sexp when point is at ( or )

#+begin_src emacs-lisp :tangle yes 

	(use-package smartparens
		:straight t 
		:defer 2
		:init
		(defun attila-sp-kill-sexp ()
			(interactive)
			(cond ((= (char-after) ?\( )
						 (call-interactively 'sp-kill-sexp))
						((= (char-before) ?\) )
						 (call-interactively 'sp-backward-kill-sexp)))
			)
		:config
		;; Sane defaults for smartparens, like do not double ' for lisp dialects
		(require 'smartparens-config)
		(smartparens-global-mode t)
		:bind
		(("<insert> k (" . attila-sp-kill-sexp)))
#+end_src

#+RESULTS:
: t

*** Autocompletion with company
#+begin_src emacs-lisp :tangle yes  

	(use-package company
		:straight t
		:defer t
		:diminish company-mode "comp"
		:init
		(add-hook 'after-init-hook 'global-company-mode)
		:config
		;; dabbrev should not downcase it completions
		(setq company-dabbrev-downcase nil)
		;; dabbrev by default only looks for
		(setq company-dabbrev-char-regexp "[a-zA-Z0-9._]")
		:bind
		(:map company-active-map
					("H-i" . 'company-select-previous)
					("H-k" . 'company-select-next)))

#+end_src

#+RESULTS:
: company-select-next

*** Yasnippet

**** Data

#+begin_src emacs-lisp :tangle yes  
	(defvar my/yas-data-og-types '("website"
																"article"
																"book"
																"music.song"
																"music.album"
																"music.playlist"
																"music.radio_station"
																"video.movie"
																"video.episode"
																"video.tv_show"
																))

	(defvar my/yas-authors '("Analogika Kft."
													 "Analogika Ltd."
													 "Hacker Space Pécs"
													 "Attila V. Molnár"))
#+end_src

**** Core

#+begin_src emacs-lisp :tangle yes  
	(use-package yasnippet
    :straight t
		:config
		(yas-global-mode 1)
		(setq yas-snippet-dirs
		'("~/.emacs.d/snippets/"))

		;; keybinding for navigating between yas fields are only used inside of a snippet,
		;; outside they would be useless so I made functions, which navigate inside a snippet
		;; However outside navigate between symbolic expression
		(defun my/yas-next-field-or-forward-sexp ()
			"Try to jump to next yas field if not in a snippet jump forward a symbolic expression"
			(interactive)
			(condition-case err
		(yas-next-field)
				(error
				 (call-interactively 'attila-smart-move-beginning-of-line))))

		(defun my/yas-previous-field-or-backward-sexp ()
			"Try to jump to next yas field if not in a snippet jump forward a symbolic expression"
			(interactive)
			(condition-case err
		(yas-prev-field)
				(error
				 (call-interactively 'move-end-of-line))))

		(define-key yas-minor-mode-map (kbd "C-j") 'my/yas-next-field-or-forward-sexp)
		(define-key yas-minor-mode-map (kbd "C-l") 'my/yas-previous-field-or-backward-sexp)
		(define-key yas-minor-mode-map (kbd "<tab>") nil)
		(define-key yas-minor-mode-map (kbd "TAB") nil)
		(define-key yas-minor-mode-map (kbd "M-e") 'yas/expand)
		:bind
		(:map snippet-mode-map
					("<insert> j t" . 'yas-tryout-snippet)))
#+end_src

#+RESULTS:
: yas-tryout-snippet

*** Smart insertions
**** TODO Path insertion

*** Line editing
**** Duplicate line above/below

#+begin_src emacs-lisp :tangle yes

	(global-set-key (kbd "<insert> l i") 'attila/line-duplicate-above)
	(global-set-key (kbd "<insert> l k") 'attila/line-duplicate-below)
#+end_src

#+RESULTS:
: attila/line-duplicate-below

** Tools
*** Version control

#+begin_src emacs-lisp :tangle yes  

	(use-package magit
		:straight t
		:config
		(defun my/magit-display-noselect-toggle ()
		"Display magit buffer but do not select window"
		(interactive)(if (equal magit-display-buffer-noselect nil)
				 (setq magit-display-buffer-noselect t) (setq magit-display-buffer-noselect nil)))
		:bind
		(("<insert> v v" . magit-status)
		 ("<insert> v l" . magit-log-buffer-file)
		 ("<insert> v i" . magit-init)
		 ("<insert> v c" . magit-clone)
		 ("<insert> v f" . magit-find-file)
		 ("<insert> v b" . magit-branch-popup)
		 ("<insert> v p" . magit-push-popup)
		 )
		:bind
		(:map magit-log-mode-map
					("s-<f3>" . magit-display-noselect-toggle)))

#+end_src

#+RESULTS:
: magit-display-noselect-toggle

** Information gathering
*** Default browser

#+begin_src emacs-lisp :tangle yes  

  (setq gnus-button-url 'browse-url-generic
        browse-url-browser-function gnus-button-url
        browse-url-generic-program
        (attila/get-first-true
         '("chromium" "vivaldi" "google-chrome-stable" "firefox")
         (function (lambda (command)
                     (if (executable-find command)
                         command
                       nil)))))

#+end_src

*** man

Break lines when displaying man pages.

#+begin_src emacs-lisp :tangle yes  

  (use-package man :straight t)

#+end_src

*** info pages

#+begin_src emacs-lisp :tangle yes  

  (use-package info-buffer
    :straight t
    :defer 4
    :bind (("<insert> h i" . info-buffer)))

#+end_src

*** Hotkey info
**** Hotkey hinting

 #+begin_src emacs-lisp :tangle yes  


	 (use-package guide-key
		 :straight t
		 :diminish guide-key-mode
		 :config
		 (setq guide-key/guide-key-sequence t)
		 (setq guide-key/recursive-key-sequence-flag t)
		 (setq guide-key/idle-delay 0.5)
		 (guide-key-mode 1))

 #+end_src

 #+RESULTS:
 : t

**** Hotkey exploration

#+begin_src emacs-lisp :tangle yes

	(use-package helm-descbinds
		:straight t
		:diminish helm-descbinds-mode)

#+end_src
** Programing
*** Elisp
**** Evaluation
#+begin_src emacs-lisp :tangle yes  

	(defun attila/lisp-eval-region-or-buffer ()
		"Eval region if selected, otherwise eval the buffer"
		(interactive)
		(if (use-region-p)
				(call-interactively 'eval-region)
			(call-interactively 'eval-buffer)))

	(define-key lisp-mode-map (kbd "<insert> j e") 'attila/lisp-eval-region-or-buffer)
	(define-key emacs-lisp-mode-map (kbd "<insert> j e r") 'attila/lisp-eval-region-or-buffer)

#+end_src

#+RESULTS:

**** Edebug

#+begin_src emacs-lisp :tangle yes  

	(define-key emacs-lisp-mode-map (kbd "<insert> d f") 'edebug-defun)
	(define-key lisp-mode-map (kbd "<insert> d f") 'edebug-defun)
	(define-key lisp-mode-map (kbd "<insert> d i") 'edebug-mode)
	(define-key emacs-lisp-mode-map (kbd "<insert> d i") 'edebug-mode)

#+end_src

#+RESULTS:
: edebug-stop

*** Org mode
**** Installation workaround

Recent org mode cannot install org-mode directly, because it needs costum build with make. This solution was borrowed from [[https:github.com/raxod502/straight.el#installing-org-with-straightel][here]].

#+begin_src emacs-lisp :tangle yes

  (require 'subr-x)
  (straight-use-package 'git)

  (defun org-git-version ()
    "The Git version of org-mode.
  Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (git-run "describe"
                "--match=release\*"
                "--abbrev=6"
                "HEAD"))))

  (defun org-release ()
    "The release version of org-mode.
  Inserted by installing org-mode or when a release is made."
    (require 'git)
    (let ((git-repo (expand-file-name
                     "straight/repos/org/" user-emacs-directory)))
      (string-trim
       (string-remove-prefix
        "release_"
        (git-run "describe"
                 "--match=release\*"
                 "--abbrev=0"
                 "HEAD")))))

  (provide 'org-version)

  (straight-use-package 'org) ;; or org-plus-contrib if desired  

#+end_src

**** Orgs headline search with org-rifle

#+begin_src emacs-lisp :tangle yes  

	(use-package helm-org-rifle
		:straight t
		:demand t
		:bind
		(:map org-mode-map
					("<insert> s m m" . helm-org-rifle-current-buffer)))
#+end_src

#+RESULTS:
: helm-org-rifle-current-buffer

**** Org tangle source code

#+begin_src emacs-lisp :tangle yes  

	(define-key org-mode-map (kbd "<insert> j e t") 'org-babel-tangle)

#+end_src

#+RESULTS:
: org-babel-tangle

*** Web
**** Web mode for HTML and CSS

#+begin_src emacs-lisp :tangle yes

	(use-package web-mode
		:straight t
		:defer t
		:init
		(add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.html\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
		(add-to-list 'auto-mode-alist '("\\.svg\\'" . xml-mode))
		(add-to-list 'auto-mode-alist '("\\.liq\\'" . liquidsoap-mode))
    
    ;; Becuase of some weird bug concatanation does not work.
		;; (setq auto-mode-alist (-concat
		;; 											 '(("\\.phtml\\'" . web-mode)
		;; 												 ("\\.tpl\\.php\\'" . web-mode)
		;; 												 ("\\.[agj]sp\\'" . web-mode)
		;; 												 ("\\.as[cp]x\\'" . web-mode)
		;; 												 ("\\.erb\\'" . web-mode)
		;; 												 ("\\.mustache\\'" . web-mode)
		;; 												 ("\\.djhtml\\'" . web-mode)
		;; 												 ("\\.html\\'" . web-mode)
		;; 												 ("\\.css\\'" . web-mode)
		;; 												 ("\\.svg\\'" . web-mode)
		;; 												 ("\\.liq\\'" . web-mode))
		;; 											 'auto-mode-alist))
		:config

		(add-hook 'web-mode-hook
							(lambda ()
								(setq-local company-backends
														(append '((company-css
																			 :separate
																			 company-web-html
																			 :separate
																			 company-dabbrev))))))
		;; turn on pair tag highlight for html
		(web-mode-toggle-current-element-highlight)
		(setq web-mode-markup-indent-offset 2)
		(setq web-mode-code-indent-offset 2)
		(add-hook 'web-mode-hook (lambda ()
															 (set (make-local-variable 'company-backends) '(company-web-html))
															 (company-mode t)
															 (emmet-mode t)))
		;;web-mode snippets
		(setq web-mode-extra-snippets
					'(("djhtml" . (("toto" . ("<% toto | %>\n\n<% end %>"))))
						("php" . (("dowhile" . ("<?php do { ?>\n\n<?php } while (|); ?>"))
											("debug" . ("<?php error_log(__LINE__); ?>")))))))
#+end_src
**** Indium JS REPL

#+begin_src emacs-lisp :tangle yes

	(use-package indium
		:straight t
		:defer t
		:init
		(add-hook 'js2-mode-hook
							(lambda ()
								(setq-local
								 company-backends
								 (append '((company-indium-repl
														:separate
														company-dabbrev)))))))

#+end_src
**** LESS

#+begin_src emacs-lisp :tangle yes  

  (use-package less-css-mode
      :straight t)

#+end_src

#+RESULTS:
**** Webkit Color picker

#+begin_src emacs-lisp :tangle yes  
  (when (>= emacs-major-version 26)
          (use-package webkit-color-picker
    :ensure t
    :straight t
    :bind
          (("<insert> 2 p" . webkit-color-picker-show))))
#+end_src

* Tests
* Postconfig
#+begin_src emacs-lisp :tangle yes  
	(toggle-debug-on-error)
#+end_src
* Planning
** TODOS
- [ ] Make my line functions prefixable
- [ ] Make my rename file or buffer function notice if the buffer is not associated to a file
** Decide
*** helm-mini or helm-buffer-list
*** parinfer mode

Parnifer mode modifies parenthesis according to indentation and vica versa
*** expand-region
Expand/shrink selection by semantic regions

